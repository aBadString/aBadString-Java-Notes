<h1 id="Java基础编程" align="center">Java 基础编程</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. Java 简介](#1-java-简介)
  - [1.1. 配置环境变量](#11-配置环境变量)
  - [1.2. Java语言版本迭代](#12-java语言版本迭代)
  - [1.3. JDK JRE JVM 三者间的关系](#13-jdk-jre-jvm-三者间的关系)
  - [1.4. Hello World 程序](#14-hello-world-程序)
  - [1.5. 注释](#15-注释)
- [2. 变量](#2-变量)
  - [2.1. 变量的声明和赋值](#21-变量的声明和赋值)
  - [2.2. Java 变量的分类](#22-java-变量的分类)
    - [2.2.1. 按数据类型分](#221-按数据类型分)
    - [2.2.2. 按声明位置分](#222-按声明位置分)
  - [2.3. 变量间的运算](#23-变量间的运算)
    - [2.3.1. 基本数据类型间的运算（不包括boolean）](#231-基本数据类型间的运算不包括boolean)
    - [2.3.2. 基本数据类型和String间的运算](#232-基本数据类型和string间的运算)
- [3. 标识符和关键字](#3-标识符和关键字)
  - [3.1. 关键字和保留字](#31-关键字和保留字)
  - [3.2. 标识符](#32-标识符)
- [4. 运算符](#4-运算符)
  - [4.1. 算术运算符](#41-算术运算符)
  - [4.2. 赋值运算符](#42-赋值运算符)
  - [4.3. 关系运算符（比较运算符）](#43-关系运算符比较运算符)
  - [4.4. 逻辑运算符](#44-逻辑运算符)
  - [4.5. 位运算符](#45-位运算符)
    - [4.5.1. 进制](#451-进制)
    - [4.5.2. 原码 反码 补码](#452-原码-反码-补码)
    - [4.5.3. 位运算](#453-位运算)
  - [4.6. 三元运算符](#46-三元运算符)
  - [4.7. 运算符的优先级](#47-运算符的优先级)
- [5. 程序流程控制](#5-程序流程控制)
  - [5.1. 顺序结构](#51-顺序结构)
  - [5.2. 分支结构](#52-分支结构)
    - [5.2.1. if – else](#521-if-else)
    - [5.2.2. switch – case](#522-switch-case)
  - [5.3. 循环结构](#53-循环结构)
    - [5.3.1. for](#531-for)
    - [5.3.2. while](#532-while)
    - [5.3.3. do – while](#533-do-while)
    - [5.3.4. continue和break](#534-continue和break)
- [6. 数组](#6-数组)
- [7. 面向对象编程基础](#7-面向对象编程基础)
  - [7.1. 包（package与import）](#71-包package与import)
  - [7.2. 访问权限修饰符](#72-访问权限修饰符)
  - [7.3. this](#73-this)
  - [7.4. super](#74-super)
  - [7.5. static](#75-static)
    - [7.5.1. static修饰变量：类变量](#751-static修饰变量类变量)
    - [7.5.2. static修饰方法：静态方法](#752-static修饰方法静态方法)
    - [7.5.3. 类加载的过程](#753-类加载的过程)
  - [7.6. final](#76-final)
  - [7.7. JavaBean](#77-javabean)
- [8. 类的成员](#8-类的成员)
  - [8.1. 属性 Field](#81-属性-field)
  - [8.2. 方法 Method](#82-方法-method)
    - [8.2.1. 方法的参数传递：值传递](#821-方法的参数传递值传递)
    - [8.2.2. 方法重载 overload](#822-方法重载-overload)
    - [8.2.3. 方法重写 override](#823-方法重写-override)
    - [8.2.4. 方法重载与方法重写的区别](#824-方法重载与方法重写的区别)
    - [8.2.5. 可变形参](#825-可变形参)
  - [8.3. 构造器 Constructor](#83-构造器-constructor)
  - [8.4. 代码块](#84-代码块)
  - [8.5. 内部类](#85-内部类)
    - [8.5.1. 匿名子类（匿名内部类）](#851-匿名子类匿名内部类)
  - [8.6. 类加载初始化和对象实例化中各个过程的顺序](#86-类加载初始化和对象实例化中各个过程的顺序)
- [9. 面向对象三大特征：封装 继承 多态](#9-面向对象三大特征封装-继承-多态)
  - [9.1. 封装性](#91-封装性)
  - [9.2. 继承性](#92-继承性)
  - [9.3. 多态性](#93-多态性)
  - [9.4. 面向对象的第四大特征：抽象性](#94-面向对象的第四大特征抽象性)
    - [9.4.1. 模板方法(TemplateMethod)设计模式](#941-模板方法templatemethod设计模式)
- [10. 接口](#10-接口)
- [11. 枚举类](#11-枚举类)
  - [11.1. 自定义枚举类](#111-自定义枚举类)
  - [11.2. enum关键字](#112-enum关键字)
  - [11.3. 枚举类中的常用方法](#113-枚举类中的常用方法)
  - [11.4. 实现接口的枚举类](#114-实现接口的枚举类)
- [12. 注解](#12-注解)
  - [12.1. jdk内置的三个常用注解](#121-jdk内置的三个常用注解)
  - [12.2. 自定义注解](#122-自定义注解)
  - [12.3. 元注解](#123-元注解)
- [13. 反射](#13-反射)
  - [13.1. 动态语言](#131-动态语言)
  - [13.2. 反射机制](#132-反射机制)
  - [13.3. Java 反射 API](#133-java-反射-api)
    - [13.3.1. 获取 Class 对象的三种方法](#1331-获取-class-对象的三种方法)
    - [13.3.2. Class 类常用方法](#1332-class-类常用方法)
    - [13.3.3. 创建对象的两种方式](#1333-创建对象的两种方式)
    - [13.3.4. 调用方法和设置属性](#1334-调用方法和设置属性)
- [14. 异常体系结构](#14-异常体系结构)
  - [14.1. Exception和Error](#141-exception和error)
  - [14.2. try – catch – finally](#142-try-catch-finally)
  - [14.3. throws](#143-throws)
  - [14.4. throw](#144-throw)
  - [14.5. 自定义异常类](#145-自定义异常类)
- [15. 多线程](#15-多线程)
  - [15.1. 程序、进程、线程](#151-程序-进程-线程)
  - [15.2. 线程安全](#152-线程安全)
  - [15.3. 线程的使用](#153-线程的使用)
    - [15.3.1. 创建线程方法一：继承Thread类](#1531-创建线程方法一继承thread类)
    - [15.3.2. 创建线程方法二：实现Runnable接口](#1532-创建线程方法二实现runnable接口)
    - [15.3.3. 创建线程方法三：实现 Callable 接口（jdk5.0新增）](#1533-创建线程方法三实现-callable-接口jdk50新增)
    - [15.3.4. 线程的调度](#1534-线程的调度)
  - [15.4. 线程的生命周期](#154-线程的生命周期)
  - [15.5. 线程同步](#155-线程同步)
    - [15.5.1. synchronized 同步代码块](#1551-synchronized-同步代码块)
    - [15.5.2. synchronized 同步方法](#1552-synchronized-同步方法)
    - [15.5.3. 同步锁 Lock ReentrantLock (jdk5.0 新增)](#1553-同步锁-lock-reentrantlock-jdk50-新增)
    - [15.5.4. 死锁](#1554-死锁)
  - [15.6. 线程通讯](#156-线程通讯)
    - [15.6.1. PV 操作](#1561-pv-操作)
    - [15.6.2. 两个线程交替打印 1~100](#1562-两个线程交替打印-1~100)
      - [15.6.2.1. 【面试题】sleep 和 wait 的异同？](#15621-面试题sleep-和-wait-的异同)
    - [15.6.3. 生产者消费者问题](#1563-生产者消费者问题)
    - [15.6.4. 再探生产者消费者模型（基本模板）](#1564-再探生产者消费者模型基本模板)
- [16. 泛型](#16-泛型)
  - [16.1. 泛型方法](#161-泛型方法)
  - [16.2. 类型擦除](#162-类型擦除)
- [17. 集合](#17-集合)
  - [17.1. List](#171-list)
  - [17.2. Set](#172-set)
    - [17.2.1. HashSet](#1721-hashset)
  - [17.3. Map](#173-map)
    - [17.3.1. HashMap（面试的重点）](#1731-hashmap面试的重点)
      - [17.3.1.1. 重要属性和常量](#17311-重要属性和常量)
      - [17.3.1.2. 构造器 (4个)](#17312-构造器-4个)
      - [17.3.1.3. 哈希函数](#17313-哈希函数)
      - [17.3.1.4. 数据结构](#17314-数据结构)
      - [17.3.1.5. public V put(K key, V value) 插入/更新](#17315-public-v-putk-key-v-value-插入更新)
      - [17.3.1.6. final Node<K,V>[] resize() 扩容](#17316-final-nodekv-resize-扩容)
      - [17.3.1.7. public V get(Object key) 查询](#17317-public-v-getobject-key-查询)
      - [17.3.1.8. 面试题](#17318-面试题)
    - [17.3.2. ConcurrentHashMap（jdk 1.7 源码）](#1732-concurrenthashmapjdk-17-源码)
    - [17.3.3. TreeMap](#1733-treemap)
      - [17.3.3.1. 红黑树](#17331-红黑树)
      - [17.3.3.2. TreeMap 源码](#17332-treemap-源码)
  - [17.4. 集合遍历方式](#174-集合遍历方式)
  - [17.5. 快速失败 (fail-fast) 和安全失败 (fail-safe)](#175-快速失败-fail-fast-和安全失败-fail-safe)
- [18. IO](#18-io)
  - [18.1. File (磁盘文件操作)](#181-file-磁盘文件操作)
  - [18.2. 字节流：InputStream 和 OutputStream （输入输出流）](#182-字节流inputstream-和-outputstream-输入输出流)
  - [18.3. 字符流：Reader 和 Writer](#183-字符流reader-和-writer)
    - [18.3.1. 字符编码](#1831-字符编码)
    - [18.3.2. BufferRead 和 BufferWriter](#1832-bufferread-和-bufferwriter)
  - [18.4. 序列化](#184-序列化)
    - [18.4.1. 序列化相关问题](#1841-序列化相关问题)
  - [18.5. NIO](#185-nio)
- [19. JDBC](#19-jdbc)
- [20. 网络编程](#20-网络编程)
- [21. JNI](#21-jni)
- [22. Java Web 三大组件](#22-java-web-三大组件)
  - [22.1. Servlet](#221-servlet)
  - [22.2. Filter](#222-filter)
    - [22.2.1. Filter的四种拦截方式](#2221-filter的四种拦截方式)
  - [22.3. Listener](#223-listener)
- [23. Java 常用类](#23-java-常用类)
  - [23.1. Object 类](#231-object-类)
    - [23.1.1. equals方法](#2311-equals方法)
    - [23.1.2. hashCode方法](#2312-hashcode方法)
    - [23.1.3. toString方法](#2313-tostring方法)
    - [23.1.4. clone方法](#2314-clone方法)
  - [23.2. 包装类(Wrapper)](#232-包装类wrapper)
    - [23.2.1. 基本数据类型、包装类、String之间的转换](#2321-基本数据类型-包装类-string之间的转换)
    - [23.2.2. 拆箱与装箱](#2322-拆箱与装箱)
  - [23.3. String类和常量池](#233-string类和常量池)
    - [23.3.1. String 的不可变性](#2331-string-的不可变性)
      - [23.3.1.1. 不可变性的好处](#23311-不可变性的好处)
    - [23.3.2. String 的几种构造器](#2332-string-的几种构造器)
    - [23.3.3. String 常用 API](#2333-string-常用-api)
    - [23.3.4. String 与其他结构的转换](#2334-string-与其他结构的转换)
    - [23.3.5. StringBuffer 和 StringBuilder](#2335-stringbuffer-和-stringbuilder)
  - [23.4. 时间有关类](#234-时间有关类)
    - [23.4.1. java.util.Date](#2341-javautildate)
    - [23.4.2. java.sql.Date](#2342-javasqldate)
    - [23.4.3. SimpleDateFormat](#2343-simpledateformat)
    - [23.4.4. java.util.Calendar 日历类](#2344-javautilcalendar-日历类)
    - [23.4.5. LocalDate、LocalTime、LocalDateTime（jdk8 新增）](#2345-localdate-localtime-localdatetimejdk8-新增)
- [24. Java 8 新特性](#24-java-8-新特性)
  - [24.1. 函数式接口](#241-函数式接口)
  - [24.2. Lambda 表达式](#242-lambda-表达式)
  - [24.3. 方法引用](#243-方法引用)
  - [24.4. 接口实现类 - 匿名内部类 - Lambda表达式 - 方法引用](#244-接口实现类-匿名内部类-lambda表达式-方法引用)
  - [24.5. 默认方法](#245-默认方法)
  - [24.6. Stream API](#246-stream-api)
  - [24.7. Date Time API](#247-date-time-api)
  - [24.8. Optional 类](#248-optional-类)
  - [24.9. 新工具](#249-新工具)
  - [24.10. Nashorn, JavaScript 引擎](#2410-nashorn-javascript-引擎)

<!-- /code_chunk_output -->

# 1. Java 简介

## 1.1. 配置环境变量
```
JAVA_HOME = C:\Program Files\JavaDevelopmentTools\jdk1.8.0_131;
Path = %JAVA_HOME%\bin;
```

## 1.2. Java语言版本迭代
1995年发布JDK1.0；JDK1.5开始改名为JDK5.0,以后都是6.0，7.0 …。
JavaSE（J2SE）：Java核心API + 桌面级应用开发
JavaEE（J2EE）：企业级开发（Web应用）
JavaME（J2ME）：移动端应用开发

## 1.3. JDK JRE JVM 三者间的关系
JDK = JRE + Java开发工具集
JRE = JVM + Java SE 标准类库

## 1.4. Hello World 程序
(1) **创建**：创建一个以.java结尾的文件
(2) **编辑**：
``` java  
public class HelloWorld {    
    public  static void main(String[] args) {        
        System.out.println("hello, world");    
    }  
} 
```
(3) **编译**：javac 源文件名.Java     可以生成一个或多个字节码文件（有几个类就有几个字节码文件）
(4) **运行**：java 字节码文件名（注意：不要.class拓展名）

说明：
1. 一个源文件中可以由多个类，但是只能有一个public类；
2. public类的名字必须和源文件名一样
3. main 返回值为 void
> 最后，与 C/C++—样，关键字 void 表示这个方法没有返回值，所不同的是 main 方法没有为操作系统返回“退出代码”。如果 main 方法正常退出，那么 Java 应用程序的退出代码为 0，表示成功地运行了程序。如果希望在终止程序时返回其他的代码，那就需要调用 System.exit 方法。
> —— 《Java核心技术 卷1 基础知识 原书第10版》P30

## 1.5. 注释
(1) **单行注释**：//
(2) **多行注释**：/* */
​    多行注释不能被嵌套使用
(3) **文档注释**：/** */
javadoc -d 目标路径 -author -version 源文件名.java


# 2. 变量

## 2.1. 变量的声明和赋值

第一种：声明变量，同时赋值
```java
// 一个变量  
int a = 1;  
// 多个变量  
int a = 1, b = 2, c = 3;  
```

第二种：先声明后赋值
```java
// 一个变量  
int a;  
a = 2;  
// 多个变量  
int a, b, c;  
a = b = c = 10;  
```

说明：
1.  变量的作用域：声明变量所在的那对大括号内；
2.  在同一个作用域内，变量命不允许重复；
3.  变量应该先声明后使用；
4.  同一个变量可以被多次赋值，后一次赋值覆盖前一次赋值。

## 2.2. Java 变量的分类

### 2.2.1. 按数据类型分

(1) 整数类型：byte、short、int、long
​    Java的整数类型有固定的表数范围和字段长度，不受具体的操作系统的影响，以保证Java程序的可移植性。
​    Java整型常量默认为int类型，long类型常量必须在末尾加上“l”或者“L”。

| **类型** | **占用的存储空间** | **表数范围**             |
| -------- | ------------------ | ------------------------ |
| byte     | 1字节              | -128 ~ 127               |
| short    | 2字节              | -32768 ~ 32767           |
| int      | 4字节              | -2147483648 ~ 2147483647 |
| long     | 8字节              | -2^63  ~ 2^63-1          |

(2) 浮点类型：float、double
​    Java的浮点类型有固定的表数范围和字段长度，不受具体的操作系统的影响，以保证Java程序的可移植性。
​    Java浮点型常量默认为double类型（也可以在末尾加上“d”或者“D”），float类型常量必须在末尾加上“f”或者“F”。
​    浮点数表示形式：
​        十进制数表示法：5.12，512.0f，.512
​        科学计数表示法：5.12e2，512E2，100E-2

| **类型** | **占用的存储空间** | **表数范围**           |
| -------- | ------------------ | ---------------------- |
| float    | 4字节              | -3.403E38 ~ 3.403E38   |
| double   | 8字节              | -1.798E308 ~ 1.798E308 |

(3) 字符类型：char 
​    Java中的字符类型是占两个字节的。其表示方式有以下三种：
```java
// 单个普通字符  
char c1 = 'A';
char c2 = '中'; 
// 转义字符  
char n1 = '\n';  
// 3. Unicode值  
char n2 = '\u0056';
char c3 = 65;  
```

| 转义字符 | 意义                                | ASCII码值（十进制） |
| -------- | ----------------------------------- | ------------------- |
| \a       | 响铃(BEL)                           | 007                 |
| \b       | 退格(BS) ，将当前位置移到前一列     | 008                 |
| \f       | 换页(FF)，将当前位置移到下页开头    | 012                 |
| \n       | 换行(LF) ，将当前位置移到下一行开头 | 010                 |
| \r       | 回车(CR) ，将当前位置移到本行开头   | 013                 |
| \t       | 水平制表(HT) （跳到下一个TAB位置）  | 009                 |
| \v       | 垂直制表(VT)                        | 011                 |
| \\       | 代表一个反斜线字符''\'              | 092                 |
| \'       | 代表一个单引号（撇号）字符          | 039                 |
| \"       | 代表一个双引号字符                  | 034                 |
| \?       | 代表一个问号                        | 063                 |
| \0       | 空字符(NUL)                         | 000                 |
| \ddd     | 1到3位八进制数所代表的任意字符      | 三位八进制          |
| \xhh     | 十六进制所代表的任意字符            | 十六进制            |

**拓展: Unicode编码与UTF-8**
**UTF-8** **是 Unicode 的实现方式之一。**
UTF-8 的编码规则很简单，只有二条：
(1) 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。
(2) 对于n字节的符号（n > 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。

![image-20200319153726395](/images/image-20200319153726395.png)

跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。

引用自: http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

(4) 布尔类型
只有true和false两个值。可以使用 1 bit 来存储，但是具体大小没有明确规定。
JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。
JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。

(5)  各类型所占字节数
```java
/**
输出Java中基本类型所占字节数
版权声明：本文为CSDN博主「阳光岛主」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/ithomer/article/details/7310008
*/
public class CalSize {
    public static void main(String[] args) {
        System.out.println("int:\t" + Integer.SIZE/8);      // 4
        System.out.println("short:\t" + Short.SIZE/8);      // 2    
        System.out.println("long:\t" + Long.SIZE/8);        // 8
        System.out.println("byte:\t" + Byte.SIZE/8);        // 1
        System.out.println("char:\t" + Character.SIZE/8);   // 2
        System.out.println("float:\t" + Float.SIZE/8);      // 4
        System.out.println("double:\t" + Double.SIZE/8);    // 8
        //System.out.println("Boolean: " + Boolean);
    }
}
```
![image-20200319153805485](/images/image-20200319153805485.png) 

### 2.2.2. 按声明位置分
（1）成员变量
（2）局部变量
![image-20200319154014930](/images/image-20200319154014930.png) 

## 2.3. 变量间的运算

### 2.3.1. 基本数据类型间的运算（不包括boolean）

**(1) 自动类型提升**

自动类型提升：小容量的变量与大容量的变量做运算，结果用大容量的变量来接收。
byte，short，char --> int --> long --> float --> double

注意：
1、容量指的是表数范围，而不是所占存储空间。float（4字节）的表数范围大于long（8字节）。
2、byte，short，char三者之间的运算都会自动提升为int类型。
![image-20200319154117223](/images/image-20200319154117223.png) 

**这是字段类型提升的一个坑：**
自动类型提升有好处，但它也会引起令人疑惑的编译错误。例如，下面看起来正确的程序却会引起问题：
```java
byte b = 50;
b = b * 2;    // Type mismatch: cannot convert from int to byte
```
如上所示，第二行会报“类型不匹配：无法从int转换为byte”错误。
![image-20200319154221155](/images/image-20200319154221155.png) 

该程序试图将一个完全合法的 byte 型的值 50*2 再存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。确实如此，在这个特别的情况下，被赋的值将仍然适合目标类型。

所以应该使用一个显示的强制类型转换，例如：
```java
byte b = 50;
b = (byte)(b * 2);
```
这样就能产生正确的值 100。

注意：char 类型比较特殊，char 自动转换成 int、long、float 和 double，但 byte 和 short 不能自动转换为 char，而且 char 也不能自动转换为 byte 或 short。

引用自：http://c.biancheng.net/view/796.html

**这是另一个坑**
float和long运算，会自动类型提升为float。例如如下代码编译错误：
```java
long l = 200L;
float f = 10.0F;
long r = l + f;
```
![image-20200319154315289](/images/image-20200319154315289.png) 

需要使用float类型变量来存储运算结果。
```java
long l = 200L;
float f = 10.0F;
float r = l + f;
```

**(2) 强制类型转换：自动类型提升的逆过程。**

格式：目标类型 变量 = (目标类型)源类型变量/常量
注意：
​    1、使用强制类型转换运算符号“(类型)”。
​    2、可能会损失精度或者类型溢出。
​    3、在强制类型转换中目标类型和源类型变量的类型始终没有发生改变。

### 2.3.2. 基本数据类型和String间的运算

​    1、 字符串和基本数据类型之间只能做连接运算，没有自动类型提升。
​    2、 字符串做链接运算的结果是字符串类型，只能用字符串来接受
​    3、 注意“+”号是做加法，还是做字符串连接符。

# 3. 标识符和关键字

## 3.1. 关键字和保留字

关键字的定义：Java关键字是Java语言里事先定义的，被赋予了特殊含义的标识符。
关键字的特点：关键字均为小写。
保留字的定义：现版本暂未使用，但以后版本可能用来作为关键字。
![image-20200321192912582](/images/image-20200321192912582.png)
![image-20200321192932199](/images/image-20200321192932199.png)

注：java官方文档有说明: “An identifier cannot have the same spelling (Unicode character sequence) as a keyword (§3.9), boolean literal (§3.10.3), or the null literal (§3.10.7), or a compile-time error occurs. While true and false might appear to be keywords, they are technically boolean literals (§3.10.3). Similarly, while null might appear to be a keyword, it is technically the null literal (§3.10.7). ”

【译文: 标识符不能具有与关键字（§3.9），布尔文字（§3.10.3）或空文字（§3.10.7）相同的拼写（Unicode字符序列），否则会发生编译时错误。 尽管true和false可能是关键字，但从技术上讲，它们是布尔文字（第3.10.3节）。 同样，尽管null似乎是一个关键字，但从技术上讲，它是null文字（第3.10.7节）。】

true false null不属于关键字，但是属于标识符。规定的关键字只有50个，包含两个保留字(goto，const)，但是这53个都属于标识符。它们之间的关系是：标识符包含 关键字、boolean literal（true,false）、 null literal; 关键字里面又包含有两个保留字。

引用自：https://blog.csdn.net/u012506661/article/details/52756452下的评论

以下是《Java 语言规范 基于 Java SE 8》一书中关于“关键字”的描述。（第15页）

![image-20200321193000464](/images/image-20200321193000464.png) 

## 3.2. 标识符

合法标识符：
​    1、 由大小写英文字母（a-z, A-Z），数字（0-9），下划线（_），美元符号（$）组成；
​    2、 不能以数字开头；
​    3、 不可以使用关键字、保留字、true、false、null
​    4、 标识符严格区分大小写，长度无限制
​    5、 标识符不能包含空格

标识符命名风格：
1.【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
2.【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式
3.【强制】类名使用UpperCamelCase风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID等。
4.【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵 从驼峰形式
5.【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字 长。
6.【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception 结尾；测试类 命名以它要测试的类的名称开始，以Test结尾
7.【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使 用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
8.【参考】枚举类名带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。
引用自：《Java 开发手册》——阿里巴巴

![image-20200321193059390](/images/image-20200321193059390.png) 
图片引用自：https://zhuanlan.zhihu.com/p/96100037
单下划线作为标识符是不可行的，但是双下划线是可行的。
```java
public class _ {
    public static void main(String[] args) {
        int _ = 99;
        System.out.println(_);
    }
}
```
![image-20200321193132879](/images/image-20200321193132879.png) 

# 4. 运算符

## 4.1. 算术运算符

![image-20200321193506653](/images/image-20200321193506653.png)

注意：
1、整数除法的结果是整数，即求整除的商。
2、取余运算只适用于两个整数，结果的正负号和被取余数的正负号相同。

## 4.2. 赋值运算符

=、+=、-=、*=、/=、%=、<<=、>>=、&=、^=、|=

设byte b = 10;，b += 2并不等于 b = b + 2。后者会进行数据类型提升，而前者数据类型不发生转换。
设int i = 1;，i *= 0.1可以相当于i = (int)(i * 0.1)。结果为0。上面的b += 2可以相当于b = (byte)(b + 2)。
```java
public class SetValue {
    public static void main(String[] args) {
        byte b = 10;
        b += 2;  // 不会进行类型转换
        System.out.println(b);
        
        b = b + 2; // 报错：类型不兼容
        System.out.println(b);

int i = 1;
        i *= 0.1; // 0，相当于 i = (int)(i * 0.1)
        System.out.println(i);
    }
}
```

【面试题】
![image-20200321193554367](/images/image-20200321193554367.png) 
答：1 编译不通过，因为short在做运算时，会先自动类型提升为int类型，所以必须用int类型的变量来接收结果。2 编译通过，s的值变为5。+=不会改变原来的数据类型，相当于 s = (short)(s+2)。

## 4.3. 关系运算符（比较运算符）

![image-20200321193702557](/images/image-20200321193702557.png)
关系运算符的结果都是boolean类型的，值要么是true，要么是false。

这里说明一下，Java和C/C++不一样，在Java中if语句的小括号里面的值或者表达式的值必须为boolean类型，否则会报错：类型不兼容。因此如果是一条int类型的赋值语句，则不能作为if的条件（在C/C++中是可以的）。但需要注意的是如果赋值表达式的左值是boolean类型的，那么赋值表达式的值也会是boolean类型的。代码如下：

```java
public class Equals {
    public static void main(String[] args) {
        boolean boo = false;

        // 这里不会报错， 因为赋值语句的值是表达式最左边变量的值
        // 即就是boo的值，是boolean类型的
        if(boo = true)
        {
            System.out.println("第一个if里面的语句执行了");
        }

        int number = 0;
        // 这里会报错：类型不兼容。因为表达式number = 3的值是number的值3
        // 而if里面所需要的值必须为boolean类型
        if(number = 3)
        {
            System.out.println("第二个if里面的语句执行了");
        }

        System.out.println("完成！");
    }
}
```

## 4.4. 逻辑运算符

& 逻辑与   | 逻辑或  ! 逻辑非
&& 短路与  || 短路或  ^ 逻辑异或

![image-20200321193755421](/images/image-20200321193755421.png)

异或：异为真。不一样，则结果为真。
说明：逻辑运算的操作数都是boolean类型，运算结果也是boolean类型。

【面试题】 &与&&，|与||的区别。
答：
![image-20200321193903747](/images/image-20200321193903747.png) 

```java
public class Logic {
    public static void main(String[] args) {
        int x, y;
        x = 0; y = 10;
        // 先判断x==0, 0==0为true，再执行x++, x=1；
        // 前面的为true，根据短路性，后面的不执行，y=10。
        if( (x++ == 0) || ((y=20) == 20) )
        {
            System.out.println("y="+y);
        }
        
        // 先执行x++, x=1；再判断x==0, 1==0为false；
        // 前面的为false，不能直接推断出结果，执行后面的语句，y=20。
        if( (++x == 0) || ((y=20) == 20) )
        {
            System.out.println("y="+y);
        }
        
        int a, b;
        a = 0; b = 10;
        // 先判断x==0, 0==0为true，再执行x++, x=1；
        // 前面的为true，没有短路性，执行后面的语句，y=20。
        // 或者把 | 理解为位运算操作符。
        if( (a++ == 0) | ((b=20) == 20) )
        {
            System.out.println("b="+b);
        }
    }
}
```
结果：
![image-20200321193935285](/images/image-20200321193935285.png) 
这篇文章对&和|的理解思路很清奇，认真看完，不要看到第一个问题就不看了。文章地址：https://blog.csdn.net/websph/article/details/5669363

## 4.5. 位运算符

### 4.5.1. 进制

世界上有10种人，一种是都二进制的，另一种是不懂二进制的。
- 二进制：0, 1，以0b或者0B开头；
- 十进制：0-9；
- 八进制：0-7，以0开头；
- 十六进制：0-9及A-B，以0x或者0X开头。A-F大小写不区分。

### 4.5.2. 原码 反码 补码

(1)  正数的原码、反码、补码都相同。（9的原码：0000 1001）
(2)  负数
负数的原码：最高位为符号位，1表示负数。即把其对应的正数的原码的符号位改为1。（-9的原码：1000 1001）
负数的反码：符号位不变，把负数的原码的其它位按位取反。（-9的反码：1111 0110）
负数的补码：反码加一。（-9的补码：1111 0111）

(byte)128 => -128
128：0000 0000, 0000 0000, 0000 0000, 1000 0000
(byte)128：1000 0000 => -128

### 4.5.3. 位运算

Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。位运算符作用在所有的位上，并且按位运算。

![image-20200321194105934](/images/image-20200321194105934.png)

<< 左移： 规则是带符号位移，高位移出，低位补0，移动位数超过该类型的最大位数，则进行取模，如对Integer型左移34位，实际上只移动了两位。左移一位相当于乘以2的一次方，左移n位相当于乘以2的n次方。

\>> 右移：规则是低位移出，高位补符号位，移动位数超过该类型的最大位数，则进行取模，如对Integer型左移34位，实际上只移动了两位。
\>>> 无符号右移：无符号位移是什么意思呢，就是右移的时候，无论正负数，高位始终补0。当然，它也仅仅针对负数计算有意义。

直接上代码：
```java
public class Bit {
    public static void main(String[] args) {
        byte a = -1; // 1111 1111
        
        byte b1 = (byte)(a >> 4);
        byte b2 = (byte)(a >>> 4);
        
        System.out.println(b1); // -1
        System.out.println(b2); // -1
        // byte类型运算时会转为int类型，后强转为byte后只有低8位，全为1。
        
        System.out.println("-------------------");
        
        int i = -1; // 1111 1111
        
        // 高位补符号位 1111 1111 1111 1111, 1111 1111 1111 1111
        int c1 = i >> 4;
        // 高位补零 0000 1111 1111 1111, 1111 1111 1111 1111  ==  ‭268435455‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬‬
        int c2 = i >>> 4; 
        
        System.out.println(c1);
        System.out.println(c2);
    }
}
```
![image-20200321194145034](/images/image-20200321194145034.png) 

这个有意思哦~ 并不是循环左移
```java
System.out.println(1 << 31);
System.out.println(3 << 31);
System.out.println(3 << 32);
System.out.println(3 << 33);
System.out.println((3 << 31) << 1); // 这个好玩
System.out.println(-1 << 32);
System.out.println(-1 << 33);
System.out.println(-1 << 34); // 得-4 不是循环左移
```
![image-20200321194218013](/images/image-20200321194218013.png) 

## 4.6. 三元运算符

(条件表达式) ? 表达式1 : 表达式2
​1、条件表达式的结果为boolean类型。
​2、条件表达式为true，执行表达式1；为false, 执行表达式2。
​3、表达式1和表达式2的类型必须相同。或者可以进行类型转换。
​4、三元运算符可以被嵌套使用，但不建议这样使用。
​5、三元运算符可以被if语句替代；反之，不成立。

## 4.7. 运算符的优先级

![image-20200321194333677](/images/image-20200321194333677.png)

# 5. 程序流程控制
## 5.1. 顺序结构
程序从上到下逐行地执行，中间没有任何判断和跳转。
## 5.2. 分支结构
根据条件，选择性地执行某段代码。
### 5.2.1. if – else
就近原则：else匹配上面离其最近的一个if。
1、    单个if
```java
if(判断条件)
{
        /* 执行代码段 */
}
```
2、    if – else
```java
if(判断条件)
{
    /* 执行代码段 */
}
else
{
/* 执行另一个代码段 */
}
```
3、    if - else if - … - else
```java
if(判断条件1)
{
    /* 执行代码段1 */
}
else if(判断条件2)
{
    /* 执行代码段2 */
}
// 。。。。。。
else
{
    /* 执行代码段n */
}
```
有多个条件表达式：
    如果关系是互斥的，那么顺序无所谓；
    如果关系是包含的，那么范围小的在上面，范围大的在下面。

### 5.2.2. switch – case
```java
switch(表达式)
{
case 常量1:
    语句1;
    break;
case 常量2:
    语句2;
    break;
//。。。。。。
case 常量n:
    语句n;
    break;
default:
    语句;
    break;
}
```
1、程序执行到break才退出switch语句块；若没有写break语句，则继续执行（**case穿透**）。
2、表达式的值必须是byte、short、char、int、枚举、String类型的。
3、case 后只能是常量，且不能有重复的值。
4、default是可选的，其位置是灵活的，只有当没有匹配到一条case时才执行。
5、先对所有的case进行匹配，如果匹配到了就不会执行default语句。

可以省略break来做一些有趣的事情：如下面，常量A匹配时要做一些事情；常量B匹配时要比匹配A时多做一些事情，且也要做A做的事情。
```java
switch(表达式)
{
case 常量B:
    做B要多做的事情;
    // 没有break语句，程序继续执行 称作case穿透
case 常量A:
    A要做的事情;
    break;
default:
    语句;
    break;
}
```

## 5.3. 循环结构
根据循环条件，重复性地执行某段代码。
1、初始化语句
2、循环条件
3、循环体
4、迭代语句

### 5.3.1. for
```java
for(初始化语句; 循环条件; 迭代语句)
{
    循环体;
}
```
执行顺序：1 -> 2 -> 3 -> 4 -> 2 -> 3 -> 4 ->…… -> 2 -> 3 -> 4 -> 2 -> 退出
循环体执行完成后执行迭代语句；退出则是从循环条件处退出。
确认一下break后不执行迭代语句，而continue后执行迭代语句：
```java
public class Loop {
    public static void main(String[] args) {
        int i;
        
        for(i = 0; i < 3; i++) {
            System.out.println(i);
            continue; // continue后执行i++
        }
        System.out.println(i);
        
        System.out.println("----------");
        for(i = 0; i < 3; i++) {
            System.out.println(i);
            if(i == 2)
                break; // break后不执行i++
        }
        System.out.println(i);
    }
}
// 结果： 
// 0
// 1
// 2
// 3
// --------
// 0
// 1
// 2
// 2
```

### 5.3.2. while
```java
初始化语句;
while(循环条件)
{
    循环体;
    迭代语句;
}
```
执行顺序：1 -> 2 -> 3 -> 4 -> 2 -> 3 -> 4 ->…… -> 2 -> 3 -> 4 -> 2 -> 退出

### 5.3.3. do – while
```java
初始化语句;
do
{
    循环体;
    迭代语句;
} while(循环条件);
```
执行顺序：1 -> 3 -> 4 -> 2 -> 3 -> 4 -> 2 -> 3 -> 4 ->…… -> 2 -> 3 -> 4 -> 2 -> 退出

### 5.3.4. continue和break
break结束外层循环：
```java
public class Break {
    public static void main(String[] args) {
        A : for(int i = 0 ; i < 10; i++) {
            for(int j = 0; j < 10; j++) {
                System.out.println("j="+j);
                if(j == 2) {
                    break A;
                }
            }
            System.out.println("i="+i);
        }
    }
}
// j=0
// j=1
// j=2
```


# 6. 数组

数组：相同数据类型的变量的集合。
​1、在Java中数组本身属于引用数据类型。
​2、数组中的元素既可以是基本数据类型，也可以是引用数据类型。
​3、**Java的数组都是分配在堆上的。**
​4、数组创建完成后，长度不可以改变。

数组的声明和初始化：
```java
// 数组的声明
String[] name;
int cs[]; // 不建议这种的
// 静态初始化
name = new String[]{"1", "2", "3", "4"};
int numbers[] = {1, 2, 3, 4};
// 动态初始化
cs = new int[5];
double d[] = new double[10];
```

数组元素的默认值：
- byte、short、int、long = 0
- float、double = 0.0
- boolean = false
- char = \u0000
- 引用类型 = null

数组的属性length用来表示数组长度。
数组的下标从0开始到 (length - 1) 结束。
```java
int[] arr = new int[10];
for (int i = 0; i < arr.length; i++) {
    arr[i] = i;
}
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```

- 数组下角标异常：ArrayIndexOutOfBoundsException
- 空指针异常：NullPointerException

Arrays 类
```java
Arrays.sort();         // 排序
Arrays.toString();     // 数组转字符串
Arrays.binarySearch(); // 二分查找
Arrays.fill();         // 内容填充
```


# 7. 面向对象编程基础

类是对象的抽象，对象是类的实例。
类的成员：属性、方法、构造器、代码块、内部类。
面向对象三大特征：封装性、继承性、多态性。
面向过程强调的是功能行为；面向对象强调的是具备了功能的类。
匿名对象：new Object()，一般用于方法的实参。

## 7.1. 包（package与import）

包的作用：为了对Java类进行统一的管理。

包命名规范：包名统一使用**小写**，点分隔符之间有且仅有一个自然语义的英文单词或者多个单词自然连接到一块（如 springframework，deepspace不需要使用任何分割）。包名统一使用**单数形式**，如果类名有复数含义，则可以使用复数形式。包名的构成可以分为以下几四部分【前缀】【发起者名】【项目名】【模块名】。常见的前缀可以分为以下几种：

![image-20200328142727668](/images/image-20200328142727668.png) 

每个“.”代表一层目录。

不同的包下面可以有相同的类名，同一个包下不能有相同的类名。（虽然Java严格区分大小写，同一个包下可以有DbContent和dbcontent；但是文件系统不区分大小写，导致文件名重复：Type with same name but different case exists.【具有相同名称但大小写不同的类型。】）

package位于源文件的首行，即package语句是代码的第一行非空行。

import：
1. 位于package语句后面，类的定义前面。
2. 用于显示地导入指定包下的类或者接口。
3. 如果需要导入多个类或者接口，则需要并列地写多条import语句。
4. 也可以使用“import java.util.*;”这种方式导入该包下的所有类或接口。
    4.1. 但是不会导入子包，例如：import java.util.*; 可以导入Scanner类，而import java.*;不能。
    4.2. 这种方法并不会导入所有的类，只会导入用到的类，编译时会替换成单类型导入。
5. 已经导入了一个包，如果还需要它的子包，那么子包还需另外导入。
6. java.lang包下的类和接口是默认自动导入的,当前包的成员本身就在作用域内所以当前包和java.lang包的导入是可以省略的。
7. 如果有使用到不同包下的同名类，只能使用类的全名来指明。
8. import static 调用指定包下指定类或接口中的静态属性和方法。

``` java
import static java.lang.System.out;
out.println("hello");
```

参考：https://blog.csdn.net/qq_25665807/article/details/74747868

## 7.2. 访问权限修饰符

对于class的访问权限只能用public和default（缺省）来修饰：
​    public：任何地方可以访问该类；
​    default：只有在同一个包下访问该类。

代码块只能用static修饰。
| **修饰符** | **类内部** | **同一个包** | **不同包的子类** | **任何地方** |
| :--------: | :--------: | :----------: | :--------------: | :----------: |
|  private   |     √      |              |                  |              |
|  （缺省）  |     √      |      √       |                  |              |
| protected  |     √      |      √       |        √         |              |
|   public   |     √      |      √       |        √         |      √       |

## 7.3. this

this表示当前对象。可以用来使用类的属性、方法和构造器。
this.属性名：用来指定当前对象的属性，this在不引起歧义时可以省略。
this.方法名()：用来调用当前对象的非静态方法，this在不引起歧义时可以省略。
this()用于调用类的其他构造器。可以多级调用，但禁止套娃。this()必须放在构造器的首行，一个构造器中只能出现一个this()。 à 推论：n个构造器中一共最多可出现n-1条this()语句。
this不能出现在静态上下文中。

## 7.4. super

super表示当前对象的父类。可以用来使用父类的属性、方法和构造器。

当父类中的方法被子类重写后，在子类中可以使用【super.方法名】来调用父类的被重写方法，使用【this.方法名】来调用子类的重写方法。如果子类没有重写，那么【super.方法名】和【this.方法名】都是调用父类的方法，或者直接使用【方法名】（省略了this.）。属性同理。

如果有一个方法继承时一路重写下来，那么【super.方法名】调用的是直接父类的方法。

super()用来调用父类的构造器。在子类的构造器中，如果没有显示地使用super()调用父类构造器，或者使用this()来调用其他构造器，那么Java默认自动的调用父类的无参构造器。如果父类没有无参构造器，就会报错【Implicit super constructor Person() is undefined. Must explicitly invoke another constructor】。（这也就解释了为什么Java会白送一个无参构造器）

super()必须放在子类构造器的首行，一个构造器中只能出现一个super()。

创建子类对象必定会调用父类构造器。

![image-20200328143202169](/images/image-20200328143202169.png) 

## 7.5. static

static可以用来修饰：属性、方法、代码块、内部类。

### 7.5.1. static修饰变量：类变量

1、同一个类的所有对象共同拥有(共享)一份类变量；每个对象各自拥有一份实例变量。
2、类变量随着类的加载而创建；实例变量随着对象的创建而创建。
3、在程序的一次运行过程中，每个类只会被加载一次。
4、使用类变量：类名.类变量名 / 对象名.类变量名。

### 7.5.2. static修饰方法：静态方法

1、静态方法随着类的加载而加载。
2、调用静态方法：类名.静态方法名(参数列表) / 对象名.静态方法名(参数列表)。
3、静态方法中不能使用非静态的实例变量，可以使用静态的类变量。静态方法中不能调用非静态的方法，可以调用静态方法。
4、非静态方法中可以使用类变量和静态方法。
5、静态方法中不能使用“this”和“super”。
6、静态方法可以被继承，但是不能被重写。

```java
public class StaticExtend {
    public static void main(String[] args) {
        A.hello(); // A
        B.hello(); // A
        C.hello(); // C

        A a = new C();
        a.hello(); // A
        ((C)a).hello(); // C
    }
}
class A {
    public static void hello() {
        System.out.println("A");
    }
}
class B extends A {
}
class C extends A {
    public static void hello() {
        System.out.println("C");
    }
}
```

【思考】什么时候使用static修饰属性和方法？
static修饰属性：
​    1、当一个属性作为常量时，必须使用static修饰。
​    2、当多个对象共同使用一份属性时。
static修饰方法：
​    1、工具类中的方法一般使用static修饰。
​    2、有时为了使用类变量，方法也会使用static修饰。


### 7.5.3. 类加载的过程

1、当我们创建对象时，首先会在方法区中查找该类的信息。
2、如果在方法区中没有找到该类的信息，则进行类加载。如果有，直接创建对象。
3、类加载：将字节码文件加载到JVM中，同时在方法区的特定区域中存放static变量。（细节：不是只有创建对象时才进行类加载，而是当我们调用类时就进行类加载）

![image-20200328143326865](/images/image-20200328143326865.png) 

## 7.6. final

final修饰的类：不能被继承。如，String、StringBuffer。
final修饰的方法：不能被重写。
final修饰的属性：必须要且仅能被赋值一次(即初始化)，且只有显示赋值、代码块赋值、构造器赋值这三种方式。
final修饰的方法体/代码块的局部变量：必须要且仅能被赋值一次，可以声明的同时赋值，也可以先声明后赋值。
final修饰的方法的形参，保证参数不被改变（如果参数是引用类型，只保证引用不改变所指对象，而对象的属性的值可以改变）。

常量：可以通过类名调用，static；常量的值不可改变，final；名称全大写。
```java
public static final double PI = 3.14159265358979323846;
```

- 对于基本类型，final 使数值不变；
- 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

## 7.7. JavaBean

JavaBean是一种Java语言写成的可重用组件。
所谓JavaBean，是指符合以下标准的Java类：
- 类是具体的，且是public的；
- 有一个无参数的public的构造器；
- 有属性，且每一个属性具有对应的get、set方法。


# 8. 类的成员

## 8.1. 属性 Field

局部变量和成员变量的相同点和不同点：
​    **相同点：**
​        1、都是变量，都要先声明后使用
​        2、都可以被多次赋值
​        3、都有其作用域
​        4、声明方式：变量类型 变量名
​    **不同点：**
​        1、声明位置：
​            成员变量声明在类内部，方法、构造器等结构外部；
​            局部变量声明在方法中、方法的形参、构造器中、构造器的形成等。
​        2、默认值
​            成员变量默认值：
​                byte、short、int、long = 0
​                float、double = 0.0
​                boolean = false
​                char = \u0000
​                引用类型 = null；
​            局部变量没有默认值。
​        3、权限修饰符
​            成员变量可以被权限修饰符修饰；
​            局部变量不能。
​        4、内存
​            成员变量存储在堆上；
​            局部变量存储在栈上。

## 8.2. 方法 Method

```java
权限修饰符 返回值类型 方法名(参数列表) {
    方法体
}
```

1、方法可以被权限修饰符所修饰。
2、使用return语句来返回一个数据；在return 语句处结束方法，返回上一层调用。
3、调用方法：对象名/类名.方法名(实参列表)。
4、形参列表中多个参数用逗号（,）分开。

### 8.2.1. 方法的参数传递：值传递

**形式参数**：方法声明时参数列表中的参数。
**实际参数**：方法调用时实际传递给方法的参数。

在Java中，方法的参数传递方式只有一种：值传递。即将实参的值复制一份传递到方法内，实参本身不受影响。按值传递重要特点：传递的是值的拷贝，也就是说传递后就互不相关了。

对于基本类型来说，传递的是实参的副本（值传递），故在方法内修改传递进来的值并不会影响实参本身；

对于引用类型来说，传递进来的是引用变量的副本（也是值传递），因此该副本与实参均是引用变量，他们均可以操作所引用的对象，在方法内通过引用变量对堆区的对象进行操作时均会对该对象有影响。由于传入方法的是实际参数值的副本，因此，参数本身不会受到任何影响！

### 8.2.2. 方法重载 overload

**方法重载的定义**

方法重载：同一个类中，方法名相同，**形参列表不同**，则构成方法重载。
不同的形参列表指：形参类型不同，个数不同，顺序不同。

注意：
1、只有返回值不同，不是重载，会报错；
2、只有形参的变量名不同，不是重载，会报错；
3、只有权限修饰符不同，不是重载，会报错。

**方法重载时的调用选择**
```java
public class MethodTest {
    public static void main(String[] args) {
        int a = 0;
        method(a);
    }

    // 以下五个方法按照调用选择顺序排列
    //方法1
    public static void method(int a){
        System.out.println("执行method(int a)");
    }
    //方法2
    public static void method(long a){
        System.out.println("执行method(long a)");
    }
    //方法3
    public static void method(Integer a) {
        System.out.println("执行method(Integer a)");
    }
    //方法4
    public static void method(Object a) {
        System.out.println("执行method(Object a)");
    }
    //方法5
    public static void method(int...a) {
        System.out.println("执行method(int...a)");
    }
}


class A {
    public static void method(int a){
        System.out.println("A类中的method()");
    }
}
public class MethodTest2 extends A{
    //方法4
    public static void method(Object a) {
        System.out.println("执行method(Object a)");
    }
    //方法5
    public static void method(int...a) {
        System.out.println("执行method(int...a)");
    }
    public static void main(String[] args) {
        int a = 0;
        method(a);
    }
}
```

关于方法重载时的调用选择我们可以得出以下结论：
​    (1)   精确匹配：对于上述代码中，当有method(int a)存在时调用的肯定就是这个方法；
​    (2)   自动类型提升：对于基础数据类型，自动转成表示范围更大的类型；当方法1被注释的时候，会去调用method(long a)而不是method(Integer a)；
​    (3)   自动装箱与拆箱：当方法1，2被注释，就调用方法3；
​    (4)   根据子类依次向上继承路线匹配：当只有方法4与方法5时，先找int的父类，找到的object类型，匹配之后调用；当继承A类之后，由于本类没有合适的方法，然后就去A类中找，匹配调用（A类中方法参数类型换成long，Integer结果也一样）；
​    (5)   根据可变参数匹配。

引用自：https://www.jianshu.com/p/306c4bfe3f54

### 8.2.3. 方法重写 override

定义：在子类中可以根据需要对从父类中继承而来的方法进行改写，也称为方法的重置、覆盖。在程序执行时，子类的方法将覆盖掉父类的方法。

要求：
1、重写方法必须和被重写方法具有相同的方法名、形参列表。
2、重写方法不能使用比被重写方法更严格的访问权限。
​3、重写方法的返回值类型要么和被重写方法一致，要么是被重写方法返回值类型的子类。如果是基本数据类型或者void，那么两者必须一样。
4、重写方法和被重写方法必须同时为非static的。如果同时为static的，不是方法重写。父类的静态方法可以被子类继承，但是不能重写，静态方法属于静态绑定。
5、重写方法抛出的异常不能大于被重写方法的异常。
6、父类中被private修饰的方法不可以被子类重写。如果子类中有相同的方法，则会被视作方法重载。

可以使用【@Override】注解来说明当前方法是一个重写方法。

Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，**动态绑定**是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。

### 8.2.4. 方法重载与方法重写的区别

**【方法重载】**：
​    1、同一个类中
​    2、方法名相同，参数列表不同（参数顺序、个数、类型）
​    3、方法返回值、访问修饰符任意
​    4、与方法的参数名无关

**【方法重写】**：
​    1、有继承关系的子类中
​    2、方法名相同，参数列表相同（参数顺序、个数、类型），方法返回值相同
​    3、访问修饰符，访问范围需要大于等于父类的访问范围
​    4、与方法的参数名无关

![image-20200403133223533](/images/image-20200403133223533.png)

### 8.2.5. 可变形参

1、格式，对于方法的形参，数据类型… 可变形参的参数名。
2、可变形参方法与同名的方法构成重载，与形参是数组的方法不构成重载(会报错)。例如：int sum(int[] array)与int sum(int... array)只能存在一个。
3、可变参数在调用时传入的实参个数从0开始，到无穷都可以。可以有sum()。
4、可变形参与数组的使用是一样的，可变形参的底层就是一个数组。
5、可变形参只能声明在方法形参列表的最后，且只能有一个可变形参。

## 8.3. 构造器 Constructor

```java
权限修饰符 类名(形参列表) {
    方法体
}
```

作用：1、创建对象；2、给对象进行初始化。
特点：
​    1、构造器的名字和类命必须一致；
​    2、构造器不具有返回值；
​    3、不能被static、final、synchronization、abstract、native修饰；
​    4、可以有return语句，但return不能返回任何值。会认为只是一个与构造器同名的方法罢了
说明：
​    1、构造器只能在创建对象时，在new语句中被调用一次。不能再其他地方**显示调用**。但可以再构造器中使用this()调用其他构造器，使用super()调用父类构造器。
​    2、如果类中没有定义构造器，那么Java免费送一个访问权限为 <del>缺省</del> ***public*** 的无参数的构造器；如果定义了构造器，就不会送了。
​    3、构造器可以重载。
​    4、构造器不会被继承给子类。

属性赋值：默认值 —> 显示赋值(声明时赋值) /代码块 —> 构造器 —> set方法或赋值语句。
显示赋值和代码块赋值属于同级的，按照由上到下的顺序执行(见图 9‑1)。

构造的过程：
​    1、分配对象空间，并将对象中成员进行默认值初始化。
​    2、执行属性值的显式初始化（这里有一点变化，一会解释，但大体是这样的）。
​    3、执行构造器的方法体（先执行父类构造器，再执行子类构造器）。
​    4、将变量关联到堆中的对象上。
关于构造器，好好看看这个：https://blog.csdn.net/yu422560654/article/details/7399566

![image-20200403133656622](/images/image-20200403133656622.png)
![image-20200403133701305](/images/image-20200403133701305.png) 


## 8.4. 代码块

![image-20200403133729754](/images/image-20200403133729754.png)

```java
{
    
}
```

代码块只能被static所修饰。
代码块分为静态代码块和非静态代码块。

静态代码块：
​    1、用来对类中的信息进行初始化。
​    2、静态代码块随着类的加载而执行，只执行一次。
​    3、静态代码块的执行优先于非静态代码块，因为要先加载类，后创建对象。
​    4、多个静态代码块按照从上到下的顺序依次执行。
​    5、静态代码块不能使用非静态的属性和方法，只能使用静态的属性和方法。

非静态代码块：
​    1、 用来对对象进行初始化。
​    2、 非静态代码块随着对象的创建而执行，每次创建对象都会执行一次。
​    3、 非静态代码块的执行优先于构造器。
​    4、 多个非静态代码块按照从上到下的顺序依次执行。

其实还有两种代码块：普通代码块，类的方法的方法体；同步代码块，使用synchronized(){}包裹起来的代码块。
这篇文章https://blog.csdn.net/u012804721/article/details/52439311

## 8.5. 内部类

在一个类A的类体中，声明了另一个类B。那么类B叫做内部类，类A叫做外部类。

```java
// 外部类
class A {
    // 非静态成员内部类
    class B {
    }
    // 静态成员内部类
    static class C {
    }

    public void say() {
        // 局部内部类
        class D {
        }
    }
}
```

内部类作为类等成员：
​    1、内部类可以被四种权限修饰符所修饰。
​    2、内部类可以被static所修饰。
​    3、内部类可以调用外部类的属性和方法。
​    4、具有类的一切功能。

**非静态内部类(成员内部类)：**
定义在类内部的非静态类，就是成员内部类。成员内部类不能定义静态方法和变量（final 修饰的除外）。局部内部类也是。
这是因为成员内部类是非静态的，类初始化的时候先初始化静态成员，如果允许成员内部类定义静态变量，那么成员内部类的静态变量初始化顺序是有歧义的。
```java
public class A {
    class B {
        private final static int ac = 12;
    }
}
```

(1) 如何创建内部类对象？
- 创建非静态内部类对象：new 外部类名().new 内部类名()
```java
A.B b = new A().new B();
```
或者
```java
import priv.song.inner.A.B;
B b = new A().new B();
```
- 创建静态内部类对象：new 外部类名.内部类名()
```java
A.C c = new A.C();
```

(2) 内部类如何调用外部类的结构（属性和方法）？
- 属性：属性名(无冲突时)，外部类名.this.属性名(有冲突时)
`name`或者`A.this.name`
- 方法：方法名(无冲突时)，外部类名.this.方法名(有冲突时)
`func()`或者`A.this.func()`
- 静态内部类不能调用非静态的属性和方法；只能调用静态的属性和方法。调用时不要this关键字即可。同样如果非静态内部类调用静态的属性或方法也不要this关键字。

(3) 如何使用局部内部类（很少）？
局部内部类不能用static，无论方法是否是static的。
获取局部内部类对象：巧用接口或父类，但是不能向下转型
```java
public class GetInner {
    public static void main(String[] args) {
        I i = getAInnerClassObject();
        i.test();
    }

    public static I getAInnerClassObject() {
        // 局部内部类
        class D implements I {
            @Override
            public void test() {
                System.out.println("D test");
            }
        }
        D d = new D();
        return d;
    }
}
interface I {
    void test();
}
```

### 8.5.1. 匿名子类（匿名内部类）

代码见：模板设计方法

如上：Main类的main方法中创建了一个继承自CodeRunTimeTest类的子类，**该子类没有名字**，叫做匿名子类。而匿名的子类的对象有名字。对于接口也有匿名实现类。

使用匿名类时，必然是在某个类中直接用匿名类创建对象，因此匿名类一定是内部类，所有又叫做匿名内部类。

匿名对象：new CodeRunTimeTest ()，一般用于方法的实参或只调用一次对象的实例方法。**创建的对象没有名字**。而该对象的类有名字CodeRunTimeTest。

匿名子类的匿名对象：https://blog.csdn.net/u013771764/article/details/82937903

```java
jumpass.addKeyListener
    (
    // 匿名内部类 - 键盘适配器
    // 创建了一个有名(KeyAdapter)抽象类的匿名子类的匿名对象
    // 作为addKeyListener方法的实参
    new KeyAdapter()
    {
        // 键入某个键时调用此方法
        public void keyTyped(KeyEvent e) 
        {
            // 如果键入的字符是0~9，或者按键是Del键或Backspace键，则
            // 直接返回读入的键盘字符，否则，设置键入的字符为键位未知（0）
            if (((e.getKeyChar() <= 0x39) && (e.getKeyChar() >= 0x30))|| (e.getKeyChar() == 127) || (e.getKeyChar() == 8)) 
            {
                e.setKeyChar(e.getKeyChar());
            } 
            else 
            {
                e.setKeyChar((char) 0);
            }
        }
    }
);
```

匿名内部类只能引用 final 所修饰的外层**局部变量**。

## 8.6. 类加载初始化和对象实例化中各个过程的顺序

下面代码的执行结果是？
```java
public class Father{
    private int i = test();
    private static int j = method();

    static{
        System.out.print("(1)");
    }
    Father(){
        System.out.print("(2)");
    }
    {
        System.out.print("(3)");
    }


    public int test(){
        System.out.print("(4)");
        return 1;
    }
    public static int method(){
        System.out.print("(5)");
        return 1;
    }
}

public class Son extends Father {
    private int i = test();
    private static int j = method();
    static{
        System.out.print("(6)");
    }
    Son(){
        this(1);
        System.out.print("(7)");
    }
    Son(int i) {
        System.out.print("(A)");
    }
    {
        System.out.print("(8)");
    }
    @Override
    public int test(){
        System.out.print("(9)");
        return 1;
    }
    public static int method(){
        System.out.print("(10)");
        return 1;
    }
    public static void main(String[] args) {
        Son s1 = new Son();
        System.out.println();
        Son s2 = new Son();
    }
}
// (5)(1)(10)(6)(9)(3)(2)(9)(8)(A)(7)
// (9)(3)(2)(9)(8)(A)(7)
```

**类初始化过程：**
1. 当使用到一个类时，就会触发加载并初始化该类。创建类的实例之前必须先加载和初始化类。
    - main 方法所在的类在程序启动时就加载并初始化。
2. 子类初始化之前需要先初始化父类
3. 类初始化的时候就是执行 `<clinit>()` 方法
    - 这个方法由编译器生成，在 class 文件中可以找到。
    - 该方法由 静态类变量显示赋值代码 和 静态代码块 组成。按照从上到下的顺序执行。
    - 该方法只会执行一次。

**实例初始化过程：**
1. 实例初始化就是执行 `<init>()` 方法
    - 该方法可能有多个重载，有几个构造器就有几个重载
    - 该方法由 非静态实例变量显示赋值代码、非静态代码块、对应构造器中的代码 组成
    - 非静态实例变量显示赋值代码、非静态代码块 按照从上到下的顺序执行，构造器中的代码最后执行
    - `<init>()` 方法第一行是 supper(...)，所以会先执行父类的 `<init>()` 方法
    - 每次创建实例对象时，都会执行



# 9. 面向对象三大特征：封装 继承 多态

## 9.1. 封装性

为什么要使用封装性：在创建对象后，可以通过对象名.属性名的方式给属性赋值，直接赋值的话，只有变量类型和范围的约束。但是在实际场景中，往往会有其他的约束。所以我们采用如下方法进行限制：
  1、对属性的访问权限进行限制，这样可以防止属性在类的外部被使用；
  2、创建对应的set方法，通过set方法来给属性赋值，在方法中对属性的值进行额外的限制。

封装性的体现（狭义上）：
  1、属性私有化；
  2、使用set/get方法对属性赋值和取值。

封装性的体现（广义上）：
  1、权限修饰符；
  2、类可以被public和（缺省）修饰；
  3、四种权限修饰符可以修饰类的属性、方法、构造器、内部类。

良好的封装的优点：
  1、良好的封装能够减少耦合。
  2、类内部的结构可以自由修改。
  3、可以对成员变量进行更精确的控制。
  4、隐藏信息，实现细节。

## 9.2. 继承性

```java  
// SubClass: 子类;  SuperClass: 超类、父类、基类  
class SubClass extends SuperClass
```

1、子类继承父类以后，就拥有了父类的所有属性和方法（但能不能访问就不一定了）。
2、子类不会继承父类的构造器。
3、子类继承父类一定要满足“is a”的关系，即子类是一个父类。
4、父类中private的属性和方法不能被子类直接访问，但是可以有get/set方法使用。
5、父类的概念是相对的，父类分为直接父类和间接父类。
6、Java中所有的类都继承Object类。如果一个类没有显示地继承某个类，那么这个类会默认继承Object类。
7、Java中只有单继承，一个类只能继承一个父类。

继承的好处：1、减少了代码的冗余，提高了代码的复用性；2、提高了代码的扩展性；3、为多态提供了前提条件。

父类与子类的关系都基于一句话：子类必须具有父类的一切功能，子类可以用来代替父类。
**里氏代换原则：任何基类可以出现的地方，子类一定可以出现。**继承的含义是不修改但扩展。
只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用。
当一个子类的实例应该能够替换任何其超类的实例时，它们之间才具有is-A关系。

上面这段话可以用来解释方法重写的要求【9.2.3】

可以看看这个讨论：https://group.cnblogs.com/topic/5960.html

## 9.3. 多态性

多态性：一类事物的多种形态。
多态性的理解（广义上）：方法的重载、重写；子类对象的多态性。
多态性的理解（狭义上）：子类对象的多态性。
子类对象的多态性：父类的引用指向子类的对象。（参考游戏开发大作业:NPC对象容器）
虚拟方法的调用（动态绑定）：编译看父类，运行看子类。
多态性的前提：继承与方法重写。

- 在多态的情况下，如何调用子类中的独有的方法？
答：向下转型。
```java
Person p = new Women();
Women w = (Women)p;
w.buy();
// 可能发生的异常：ClassCastException  —类型转换异常
```

- 如何防止类型转换异常？
答：instanceof。
```java
Person p = new Women();
if(p instanceof Women) {
Women w = (Women)p;
w.buy();
}
```

**注意：属性没有多态性！**因为属性不存在重写

```java
public class Person {
    String name = "Person";
void show() {
        System.out.println("Person.show()");
    }
}
public class Man extends Person {
    String name = "Man";
@Override
void show() {
        System.out.println("Man.show()");
    }
}

public class Main {
    public static void main(String[] args) {
        Person p = new Man();
        System.out.println(p.name);
        p.show();
        
        if(p instanceof Man)
        {
            Man m = (Man)p;
            System.out.println(m.name);
            m.show();
        }
    }
}
```
结果：
![image-20200403134740251](/images/image-20200403134740251.png) 

看看上述代码在C++中的运行情况：
```C++
#include <iostream>
class Person 
{
public:
    char* name = "Person";
    void show();
};
void Person::show()
{
    std::cout << "Person.show()" << std::endl;
}
class Man : public Person 
{
public:
    char* name = "Man";
    void show();
};
void Man::show()
{
    std::cout << "Man.show()" << std::endl;
}

int main()
{
    Person *p = new Man();
    std::cout << p->name << std::endl;
    p->show();

    Man *m = (Man*)p;
    std::cout << m->name << std::endl;
    m->show();
}
```
结果： 
![image-20200403134815844](/images/image-20200403134815844.png) 

把Person中的方法改成虚方法： ![image-20200403134831337](/images/image-20200403134831337.png)
结果：
![image-20200403134824416](/images/image-20200403134824416.png) 


## 9.4. 面向对象的第四大特征：抽象性

abstract修饰的方法：抽象方法
  1、抽象方法没有方法体。
  2、抽象方法所在的类必须是抽象类。

abstract修饰的类：抽象类
  1、抽象类不能够显示的调用其构造器来实例化。
  2、必须由其子类来重写抽象类的全部抽象方法后，才可以实例化。
  3、抽象类是有构造器的，并且要由其子类的构造器来隐式调用。
  4、抽象类中可以有非抽象方法。也可以没有一个抽象方法。但是这样就没有什么意义。
  5、抽象类的子类可以还是抽象类，只实现了部分方法或完全没有实现。

abstract不能修饰属性、私有方法、静态方法、代码块、构造器、final方法和final类。
abstract不能和final、private、static一起使用。

### 9.4.1. 模板方法(TemplateMethod)设计模式

![image-20200403135019574](/images/image-20200403135019574.png)

```java
abstract class CodeRunTimeTest {
    /*
     * 测试方法
     */
    public long countRunTime()
    {
        // 1.记录开始运行的时间
        long start = System.currentTimeMillis();
        // 2.执行被测代码
        runCode();
        // 3.记录运行结束的时间
        long end = System.currentTimeMillis();
        // 4.返回时间差
        return (end - start);
    }
    /*
     * 被测方法, 由子类重写
     * C#中的委托
     */
    protected abstract void runCode();
}

public class Main {
    public static void main(String[] args) {
        // 创建了一个有名抽象类的匿名子类的有名对象
        CodeRunTimeTest test = new CodeRunTimeTest() {
            @Override
            protected void runCode() {
                System.out.println("重写了被测方法");                
            }
        };
        System.out.println(test.countRunTime());
    }
}
```


# 10. 接口

格式：

```java
[public] interface 接口名称 [extends 其他的接口名, 其他的接口名 … ] { 
    // 声明常量
    // 抽象方法 
}
```

1、接口和类之间是并列关系。
2、接口不能被实例化，接口没有构造器。
3、接口中只能有常量和抽象方法（jdk1.8之前）。
    **常量**：public static final double PI = 3.14; (public static final可以省略，这三者无论怎样组合，最终都会被补全。如：final, static, public, static final, public static, public final。抽象方法和静态方法同理。)
    **抽象方法**：public abstract void fly(); (public abstract可以省略)

4、jdk1.8新特性：接口中还可以有静态方法和默认方法。
    **静态方法：** public static void show(){} (public可以省略，一定是public的)
    **默认方法：** public default void show(){} (public可以省略，一定是public的)
    静态方法调用：接口名.静态方法名；默认方法调用：实现类的对象名.默认方法名。(???这不就是抽象类了么。。。)

5、接口和接口之间的关系：接口 extends 接口，可以多继承。
6、类和接口之间的关系：类 implement 接口，可以实现多个接口。
7、一个非抽象类实现接口后，必须重写所有接口的**所有**抽象方法。如果没有全部重写，则需把类声明为抽象类。
8、接口只能被public、abstract修饰：前者控制接口的访问范围：public或者缺省的。abstract可以省略。https://blog.csdn.net/sanpangouba/article/details/87349241
9、接口主要用来定义规范，解除耦合关系。
10、父类和接口中有相同的方法：类优先原则。
11、两个接口中有相同的抽象方法，那么实现类只需重写一次，即同时重写这两个方法。
12、如果两个接口有相同的默认方法，实现类必须重写该方法；若不重写，则编译报错。


在实现类的方法中调用接口的默认方法：接口名.super.默认方法名()。

```java
public class Main {
    public static void main(String[] args) {
        new C().say();
    }
}
interface A {
    public default void say() {
        System.out.println("A");
    }
}
interface B {
    public default void say() {
        System.out.println("B");
    }
}
class C implements A, B {
    @Override
    public void say() {
        A.super.say();
        B.super.say();
        System.out.println("C");
    }
}
// 结果：
// A
// B
// C
```

接口名 变量名 = new 接口实现类(); // 接口类型的引用可以指向接口实现类的对象。

同样，接口也可以和抽象类一样，有匿名实现类。       

![image-20200526193221604](/images/image-20200526193221604.png)

![image-20200526193240930](/images/image-20200526193240930.png) 


# 11. 枚举类

枚举类：一个类的对象的数量是可数的有限个数，这样的类叫做枚举类。(单例模式？)

## 11.1. 自定义枚举类

jdk1.5以前我们这样玩：
```java
public class Main {
    public static void main(String[] args) {
        Season season = Season.SPRING;
        System.out.println(season.value() + " " + season.name());
        season = Season.WINTER;
        System.out.println(season.value() + " " + season.name());
    }
}
/* 自定义枚举类 */
final class Season {
    // 3.无法修改的属性：名字和值
    private final String name;
    private final int value;
    // 1.私有化构造器
    private Season(String name, int value) {
        this.name = name;
        this.value = value;
    }
    // 2.创建本类的可数个对象
    public static final Season SPRING = new Season("春天", 0);
    public static final Season SUMMER = new Season("夏天", 1);
    public static final Season AUTUNM = new Season("秋天", 2);
    public static final Season WINTER = new Season("冬天", 3);
    // 4.属性的同名get方法
    public String name() {
        return name;
    }
    public int value() {
        return value;
    }
}
// 结果：
// 0 春天
// 3 冬天 
```

## 11.2. enum关键字

jdk1.5引入了enum关键字，我们就可以这样玩了：
```java
enum Season{
    SPRING, SUMMER, AUTUNM, WINTER;
    private Season() {}
}
```
创建枚举类的对象必须放在枚举类的类体的首行，多个对象之间用逗号(，)隔开，以分号结尾。（如果类体中只有枚举类的对象，分号可以省略；但如果还有其他结构如(构造器)，则一定要分号。）
枚举类的构造器一定是私有的(private)，默认送一个空参的私有的构造器。
枚举类中可以加上私有的属性和有参构造器：
```java
enum Season{
    SPRING("春天"), // 这样子调用有参构造器, C++: ???
    SUMMER("夏天"),
    AUTUNM("秋天"),
    WINTER("冬天");
    // 私有属性
    private final String seasonName;
    private Season(String name) {
        this.seasonName = name;
    }
    public String getSeasonName() {
        return seasonName;
    }
}
```

## 11.3. 枚举类中的常用方法

enum关键字定义的枚举类会帮我们自动继承Enum类，并创建我们指定名字的那些本类的静态对象。其底层原理和前面的自定义枚举类原理差不多。
可以看看这篇 https://blog.csdn.net/javazejian/article/details/71333103
其父类Enum中提供了一些方法。
values()方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值。
valueOf(String str)方法：可以把一个字符串转化为对应的枚举类对象。要求字符串必须是枚举类对象的名字。如果不是，则会抛出IllegalArgumenException异常

## 11.4. 实现接口的枚举类

枚举类可以用来实现接口。
它可以像普通的类一样实现接口：
```java
public class Main {
    public static void main(String[] args) {
        Season season = Season.SPRING;
        season.info();
    }
}
interface I {
    void info();
}
enum Season implements I{
    SPRING,
    SUMMER,
    AUTUNM,
    WINTER;
    @Override
    public void info() {
        System.out.println("Season - I.info()");        
    }
}
```
枚举类的每个对象都可以单独实现接口的方法：对象所实现的方法里面可以使用super来调用枚举类所实现的方法。
```java
interface I {
    void info();
}
enum Season implements I{
    SPRING{
        @Override
        public void info() {
            super.info();
            System.out.println("spring info()");
        }
    },
    SUMMER{
        @Override
        public void info() {
            System.out.println("summer info()");
        }
    },
    AUTUNM{
        @Override
        public void info() {
            System.out.println("autunm info()");
        }
    },
    WINTER{
        @Override
        public void info() {
            System.out.println("winter info()");
        }
    };
    @Override
    public void info() {
        System.out.println("Season - I.info()");        
    }
}
```


# 12. 注解

## 12.1. jdk内置的三个常用注解
 
@Override：限定重写父类或者接口的方法，该注解只能用于方法。
@Deprecated：用于表示某个程序结构(类、方法、属性、构造器等)已过时。
@SuppressWarnings：抑制编译器警告，需要参数，参数是一个字符串数组。`@SuppressWarnings("unused") : The value of the local variable a is not used`


## 12.2. 自定义注解
```java
格式：@interface 注解名 {
}
```
```java
@interface MyAnn {
    // 可以认为是声明了一个属性
    String name();
    // 属性可以有默认值
    int age() default 20;
}
@MyAnn(name = "111", age = 18)
class SuperClass {
    @MyAnn(name = "111")
    public void show() {
        
    }
}
```

如一个注解内仅只有一个成员变量且名字为 value 的属性时，应用这个注解时可直接写属性值到括号内。
注解没有任何属性，或者属性都使用默认值，括号都可以省略。

## 12.3. 元注解
元注解：可以理解成注解上的注解。元注解是用来给注解进行补充说明的。
 
- **@Target：目标**。用来指定注解可以使用在说明类型的结构上：属性、方法、类等。
```java
@Target(ElementType.METHOD) // 该注解只能用于方法上
@interface MyAnn3 {
    
}
```
ElementType是一个枚举，其源码(jdk1.8)如下：
```java
public enum ElementType {
    TYPE, /** 类,接口(包括注解类型),或枚举声明 */
    FIELD, /** 属性声明(包含枚举常量) */
    METHOD, /** 方法声明 */
    PARAMETER, /** 形参声明 */
    CONSTRUCTOR, /** 构造器声明 */
    LOCAL_VARIABLE, /** 局部变量声明 */
    ANNOTATION_TYPE, /** 注解类型声明 */
    PACKAGE, /** 包声明 */
    TYPE_PARAMETER, /** Type parameter declaration @since 1.8 */
    TYPE_USE /** Use of a type @since 1.8 */
}
```

- **@Retention：保留策略**。注解保留到什么时候可以用，源文件, 字节码文件, 运行时。
一般自定义注解使用RUNTIME。
```java
@Retention(RetentionPolicy.SOURCE)
@interface MyAnn3 {
    
}
```
RetentionPolicy是一个枚举，其源码(jdk1.8)如下：
```java
public enum RetentionPolicy {
    SOURCE, /** 注解将被编译器丢弃。*/
    CLASS, /** 注解由编译器记录在类文件中,但是在运行时不需要被VM保留。这是默认的*/
    RUNTIME /** 注解将被编译器记录在类文件中在运行时被VM保留，因此可以利用反射特性来读取它们。*/
}
```

- **@Documented**。被它修饰的注解会在生产的 javadoc 文件上出现。

- **@Inherited**。标记注解是可以被继承的。
如果定义一个注解 @A 时使用了@Inherited 修饰的，那么 @A 被用于修饰一个类 C，则这个注解 @A 将被继承给类 C 的子类。


# 13. 反射

## 13.1. 动态语言

动态语言，是指程序在运行时可以改变其结构：新的函数可以引进，已有的函数可以被删除等结构上的变化。
比如常见的 JavaScript 就是动态语言，除此之外 Ruby,Python 等也属于动态语言，而 C、C++则不属于动态语言。从反射角度说 JAVA 属于半动态语言。

## 13.2. 反射机制

反射：运行状态中知道类所有的属性和方法等。
反射：主要是指程序可以访问，检测和修改它本身状态或行为的一种能力，并能根据自身行为的状态和结果，调整或修改应用所描述行为的状态和相关的语义。

Java 的反射：在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且对于任意一个对象，都能够调用它的任意一个方法；这种动态获取信息以及动态调用对象方法的功能成为 Java 语言的反射机制。

反射机制主要提供以下功能：
1. 在运行时判断任意一个对象所属的类；
2. 在运行时构造任意一个类的对象；
3. 在运行时判断任意一个类所具有的成员变量和方法；
4. 在运行时调用任意一个对象的方法；
5. 生成动态代理。

## 13.3. Java 反射 API

```java
// 类
java.lang.Class;
// 构造器
java.lang.reflect.Constructor;
// 属性
java.lang.reflect.Field;
// 方法
java.lang.reflect.Method;
// 访问修饰符
java.lang.reflect.Modifier;
```

**优点：** 
（1）能够运行时动态获取类的实例，大大提高系统的灵活性和扩展性。
（2）与Java动态编译相结合，可以实现无比强大的功能 
**缺点：** 
（1）使用反射的性能较低
（2）使用反射相对来说不安全
（3）破坏了类的封装性，可以通过反射获取这个类的私有方法和属性

### 13.3.1. 获取 Class 对象的三种方法

1. 调用某个对象的 getClass() 方法，getClass() 在 Object 中
```java
Person p = new Person();
Class clazz = p.getClass();
```
2. 调用某个类的 class 属性来获取该类对应的 Class 对象
```java
Class clazz = Person.class;
```
3. 使用 Class 类中的 forName() 静态方法 (最安全/性能最好)
```java
Class clazz = Class.forName("类的全路径"); (最常用)
```

### 13.3.2. Class 类常用方法

```java
// 获取全限定类名
public String getName()

// 获取直接父类全限定类名
public native Class<? super T> getSuperclass()
// 获取实现的所有接口的全限定类名
public Class<?>[] getInterfaces()

// 获取所有 public 构造器
public Constructor<?>[] getConstructors()


// 获得某个类的所有的公共（public）的字段，包括父类中的字段
public Field[] getFields() 
// 获得某个类的所有声明的字段，即包括public、private和proteced，但是不包括父类的申明字段。
public Field[] getDeclaredFields()

// 获取某个类的所有 public 方法，包括继承自父类的
public Method[] getMethods()
// 获取某个类的所有方法，仅包含自己定义的
public Method[] getDeclaredMethods()

// 调用空参构造器创建对象
public T newInstance()
```

### 13.3.3. 创建对象的两种方式

1. 使用 Class 对象的 newInstance()方法来创建该 Class 对象对应类的实例，但是这种方法要求该 Class 对象对应的类有默认的空构造器。
```java
Class clazz = Class.forName("reflection.Person"); 
Person p = (Person) clazz.newInstance();
```
2. 使用 Constructor 对象的 newInstance() 方法来创建 Class 对象对应类的实例，通过这种方法可以选定构造方法创建实例。
```java
Class clazz = Class.forName("reflection.Person"); 
Constructor c = clazz.getDeclaredConstructor(String.class, String.class, int.class);
Person p = (Person) c.newInstance("李四", "男", 20);
```

### 13.3.4. 调用方法和设置属性

调用方法：使用 Method 类的 invoke 方法
```java
public Object invoke(Object obj, Object... args)
```
第一个参数是一个对象的引用，用来指明通过哪个对象调用方法。

设置属性值：使用 Filed 类的 set 方法
```java
public void set(Object obj, Object value)
```
第一个参数是一个对象的引用，用来指明设置哪个对象属性。


# 14. 异常体系结构

## 14.1. Exception和Error
异常：在Java语言中，将程序执行过程中发生的不正常情况称为异常。（开发过程中的语法错误和逻辑错误不是异常）
Error错误：Java虚拟机无法解决的严重问题。如，JVM系统内部错误、资源耗尽等严重情况。比如，StackOverflowError和OOM（什么是OOM？OutOfMemoryError：程序申请内存过大，虚拟机无法满足我们，然后自杀了）。一般不编写针对性代码进行处理。
Exception异常：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。
两种堆栈错误：
```java
// StackOverflowError
main(args);
// OutOfMemoryError
int[] p = new int[1024 * 1024 * 1024];
```
异常体系的类关系：
```java
|-- Throwable
    |-- Error
        |-- java.lang.StackOverflowError
        |-- java.lang.OutOfMemoryError
    |-- Exception
        // 编译时异常：CheckedException（必须进行处理，否则不能通过编译）
        // 并没有 CheckedException 这个类，只有不是继承自 RuntimeException 的异常类都是编译时异常
        |-- IOException
            |-- FileNotFoundException
        |-- ...
        // 运行时异常（这里真的有RuntimeException这个类）
        |-- RuntimeException
            |-- NullPointerException
            |-- IndexOutOfBoundsException
                |-- ArrayIndexOutOfBoundsException
                |-- StringIndexOutOfBoundsException
            |-- IllegalArgumentException
            |-- ClassCastException
            |-- ...
```

## 14.2. try – catch – finally
``` java
try {
    可能会发生异常的代码
} catch(异常类型1 e) {
    类型1异常处理代码
} catch(异常类型2 e) {
    类型2异常处理代码
}
...
catch(Exception e) { // 一般这样写，以防止未考虑到的异常出现。（多态）
    类型n异常处理代码
} finally {
    离开try-catch结构时一定会执行的代码
}
```

在try语句块中的代码，一旦某一行代码发生异常，系统将会创建相应的异常对象，并抛出，**后面的try语句块中的代码就不会执行了**。
然后根据catch中的异常类型从上往下依次进行匹配，一旦匹配成，则执行异常处理代码。然后执行finally语句块，离开try-catch结构。**继续执行try-catch结构后面的代码**。
如果都匹配失败则程序终止运行，并且**终止之前会执行finally语句块**。

1、try语句块中发生异常的那一行代码后面的代码不会执行了
2、无论是否发生异常，无论是否抓到异常，离开try-catch结构时finally语句块的代码一定被执行。就算catch中再次发生异常，finally仍然会执行。即使catch中有return，还是会执行。
3、如果正常的处理了异常，那么会继续执行try-catch结构后面的代码。
4、多个catch语句，子类在上，父类在下。
5、catch和finally语句都是可选的。但至少要有其中一个，不能单单只有try。
6、获取依次信息：getMessage()、printStackTrace()。

看看这个，牛逼咯！
```java
public class FinallyTest {
    public static void main(String[] args) {
        int value = getRetrunValue();
        System.out.println(value);
    }
    
    public static int getRetrunValue() {
        try {
            System.out.println(1 / 0);
        } catch(Exception ex) {
            return 10;
        } finally {
            return 20;
        }
    }
}
// 结果：20 
```
原因：函数的信息存储在栈帧中，函数的返回值也是放在栈帧的一个位置上。return语句会将返回值放在该位置上，并终止本层函数，返回上一层调用。return了两次，后一次值覆盖了前一次值。

这个更牛逼！！！！
try块中如果有System.exit();代码就会不执行finally块代码
```java
public static void main(String[] args) {
    try{
        System.exit(0);
    } finally {
        System.out.println("exit()调用后不执行dinally");
    }
}
// 输出：
```


## 14.3. throws
格式：方法名(形参列表) throws 异常类型1, 异常类型2, … { 方法体 }

throws并没有真正处理掉异常，而是将异常向上抛出，抛给方法的调用者，由其处理。
如果父类被重写方法没有抛出异常，那么子类重写方法也不能抛出异常。
子类重写方法所抛出的异常不大于父类被重写方法所抛出的异常。

## 14.4. throw
格式：throw 异常类对象;
一般throw编译时异常的时候，我们都使用throws将其抛给上层方法处理。

【面试题】throw和throws的区别？
throw：是用来制造异常的，是用来向外抛出异常的。
throws：是用来声明异常，让调用者知道该方法可能抛出的异常。
只是可能会抛出声明的类型的异常，并不一定会发生这些类型的异常；还可能抛出未声明到类型的异常。

即使方法没有使用 throws 声明异常，当方法内发生异常时，调用者仍然可以捕获到异常。
```java
public static void main(String[] args) {
    try {
        show();
    } catch (Exception e) {
        System.out.println("抓到异常啦");
    }
    System.out.println("哈哈");
}
static void show () {
    int a = 1/ 0;
}
// 输出：
// 抓到异常啦
// 哈哈
```

## 14.5. 自定义异常类

```java
public class MyException extends Exception {
    // 。。。
}
```

![](/images/异常处理总结.png)


# 15. 多线程
## 15.1. 程序、进程、线程
程序：是为完成特定任务、用某种语言编写的一组指令的有序集合。是指一段静态的代码。
进程：是一个程序在一个数据集合上的一次运行。是操作系统分配资源的最小单位。进程具有生命周期，是一个动态的过程。
线程：是进程的一个实体，是进程内部的一条执行路径。是处理器调度的基本单位。

一个Java应用至少有三个线程：main主线程、GC垃圾回收线程、异常处理线程。

## 15.2. 线程安全

编写线程安全的代码，本质上就是管理对对象的状态的访问，而且这些状态通常都是**共享的、可变的**。
一个对象的**状态**就是它的数据，存储在状态变量中。**共享**就是一个变量可以被多个线程访问。可变是指变量的值在其生命周期内是可以被**改变**的。

线程安全的定义：一个类是线程安全的，是指在被多个线程访问时，类可以持续进行正确的行为。
![image-20200323173052585](/images/image-20200323173052585.png)

按照线程安全的安全程度分：
1. 不可变：final、java.lang.String的对象、枚举、Integer是不可变对象。
2. 绝对线程安全：不论何种环境下，不需要做任何额外同步措施。
3. 相对线程安全：对这个对象**单独**操作时是线程安全的，不需要额外的同步措施；但是对于某些特定顺序的连续调用，就可能需要使用额外的同步手段保证调用的正确性。Vector、HashTable 等同步容器。（这一级别就是我们通常讲的线程安全）
4. 线程兼容：对象本身不是线程安全的，可以通过调用段使用同步手段来保证对象安全。HashMap、ArrayList。（这一级别就是我们通常讲的线程不安全）
5. 线程对立：不管采用哪种方式，都不能并发的使用。（suspend和resume；System.setIn和System.setOut和System.runFinalizersOnExit）

线程安全的类封装了任何必要的同步，因此客户不需要自己提供。
**无状态对象永远是线程安全的。** 多数 Servlet 都可以实现为无状态的。
**不可变对象永远是线程安全的。**
不可变对象需要满足：
- 它的状态不能在创建后再被修改
- 所以字段都是 final 类型
- 该对象被正确顺序的创建（创建期间没有发生this引用逸出）

**原子操作**
![image-20200323180121239](/images/image-20200323180121239.png)

**设计线程安全的类**
设计线程安全的类包括以下三要素：
1. 确定对象状态是由哪些变量构成的
2. 确定限制状态变量的不变约束
3. 制定一个管理并发访问对象状态的策略


## 15.3. 线程的使用

### 15.3.1. 创建线程方法一：继承Thread类
```java
// 1、继承 Thread 类
class MyThread extends Thread {
    // 2、重写 run 方法, 该方法就是线程执行的代码
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i + " t1");
            }
        }
    }
}

public class ThreadTest {
    public static void main(String[] args) {
        // 3、新建一个子类的实例
        MyThread t1 = new MyThread();
        // 4、执行该实例的 start 方法
        t1.start();

        System.out.println("main 线程继续执行");
        for (int i = 0; i < 100; i++) {
            if (i % 2 != 0) {
                System.out.println(i + " main");
            }
        }
    }
}
```
- 一个Thread的实例对象只能够start一次，第二次start时会抛出异常：
```java
public synchronized void start() {
    if (threadStatus != 0)
        throw new IllegalThreadStateException();
```
- 匿名子类的写法：
```java
new Thread("t1") {
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}.start();
```

**Thread常用方法：**
1、    start()：1、启动一个线程；2、调用该线程的run()方法。
2、    run()：该方法需要子类去重写，该方法就是线程执行的代码。
3、    Thread.currentThread()：类方法，返回当前线程对象，返回值Thread。
4、    getName()：获取线程名字。
5、    setName()：设置线程名字。
6、    this.yield()：使线程从执行状态变为就绪状态，释放当前CPU的使用权（线程让步）。
7、    xxx.join()：当前线程进入阻塞状态，等待xxx线程执行完成之后再执行。
8、    stop()：已过时，强制结束线程。
9、    Thread.sleep(long millis)：线程阻塞millis毫秒。
10、    isAlive()：判断线程是否存活。


### 15.3.2. 创建线程方法二：实现Runnable接口
```java
// 1、实现 Runnable 接口
class MyRunnable implements Runnable {
    // 2、重写 run 方法, 该方法就是线程执行的代码
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
            }
        }
    }
}

public class RunnableTest {
    public static void main(String[] args) {
        // 3、创建 Runnable 实现类对象
        MyRunnable m = new MyRunnable();
        // 4、创建 Thread 对象
        Thread t = new Thread(m);
        // 5、执行 start 方法、
        t.start();
    }
}
```

推荐使用实现Runnable接口的方式，因为继承是is-a的关系。一个类不应该is-a线程，正确的应该是一个类具有多线程运行的功能。第二，通过Runnable实现类创建几个线程对象，这些线程共享一个Runnable实现类对象，该对象的成员变量由所有线程共享。
Thread本身也是实现了Runnable接口：public class Thread implements Runnable

### 15.3.3. 创建线程方法三：实现 Callable 接口（jdk5.0新增）

与 Runnable 相比 Callable 接口：
1. 相比 run() 方法，call() 方法可以用返回值
2. 方法可以抛出异常
3. 支持范型的返回值
4. 可以借助 FutureTask 类来获取返回结果


```java
public class FutureTask<V> implements RunnableFuture<V>
public interface RunnableFuture<V> extends Runnable, Future<V>
```

```java
// 1、创建一个 Callable 接口的实现类
class Num implements Callable<Integer> {
    // 2、重写 call() 方法
    @Override
    public Integer call() throws Exception {
        System.out.println("run task");
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            if (i % 2 == 0) {
                System.out.println(i);
                sum += i;
            }
        }
        return sum;
    }
}

public class CallableTest {
    public static void main(String[] args) {
        // 3、创建 Callabel实现类的实例对象
        Callable num = new Num();
        // 4、创建 FutureTask 实例对象，该对象实现了 Runnalbe 接口
        FutureTask<Integer> task = new FutureTask<Integer>(num);
        // 5、创建 Thread 对象，并调用 start() 方法
        new Thread(task).start();
        // 同一个 task 被 start 多次时，只会start一个线程
        // 只会输出一次 run task
        new Thread(task).start();
        // 如果想要 start 多次，则必须 new 多个 tsak 对象
        //new Thread(new FutureTask<Integer>(num)).start();

        System.out.println("1. 主线程继续运行。。。");

        try {
            // 6、获取 Callable 接口实现类 call() 方法的返回值
            // get 方法内部有一个 awaitDone 方法，主线程会等待子线程执行完毕，在继续执行
            Integer o = task.get();
            System.out.println("sum" + o);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        System.out.println("2. 主线程继续运行。。。");
    }
}

// 结果：
// run task
// 0
// 2
// 1. 主线程继续运行。。。
// 4
// 。。。
// 98
// sum2450
// 2. 主线程继续运行。。。
```

Thread 类只有传 Runnable 接口的构造器，而没有传 Callable 的；那么它是怎么通过 Callable 创建线程的呢？
FutureTask 类实现了 RunnableFuture 接口，RunnableFuture 继承自 Runnable 接口；同时 FutureTask 类提供了一个 Callable 的构造器。FutureTask 相当于一个适配器。


### 15.3.4. 线程的调度
时间片轮转：时间片到，放弃CPU
优先级调度：高优先级线程先使用CPU
Java的调度策略：同级线程先来先服务，使用时间片轮转；高优先级线程优先调度。

线程优先级：
MIN_PRIORITY     1
NORM_PRIORITY     5    默认的
MAX_PRIORITY     10


## 15.4. 线程的生命周期
```java
public enum State {
NEW,
RUNNABLE,
BLOCKED,
    WAITING,
TIMED_WAITING,
    TERMINATED;
}
```
① 新建状态(NEW)：一个尚未启动的线程所处的状态；
② 可运行状态(RUNNABLE)：可运行线程的线程状态，**可能正在运行，也可能在等待处理器资源**；
③ 阻塞状态—锁阻塞(BLOCKED)：被阻塞等待监视器锁定的线程所处的状态（即当一个线程试图获取锁，但锁此时被其他线程持有，该线程进入BLOCKED状态，当线程拿到锁则进入RUNNABLE状态）；
④ 阻塞状态—无限等待（WAITING）：未指定等待时间的线程所处的状态（调用Object.join()或Object.wait()方法时进入此状态，一个线程处于该状态时，只能被另一个线程唤醒，而不能自己主动唤醒，另一个线程调用notify()或notifyAll()来唤醒该线程）；
⑤ 阻塞状态—定时等待（TIMED_WAITING）：指定等待时间的线程所处的状态（调用Thread.sleep(long)或Object.join(long)或Object.wait(long)方法时进入此状态，直到时间超时或收到唤醒通知，注意wait(0)时是可以自己苏醒的，比如当Thread结束时就会自动苏醒）；
⑥ 终止状态（TERMINATED）：已经执行完成的线程状态。

参考：https://blog.csdn.net/Alexshi5/article/details/88045763

![](/images/线程的生命周期.png)

## 15.5. 线程同步

### 15.5.1. synchronized 同步代码块

执行线程进入 synchronized 块之前会自动获得对象的内部锁，离开 synchronized 块时自动释放锁。获得内部锁的唯一途径是进入这个内部锁保护的同步块或方法。
内部锁是互斥锁，至多只有一个线程可以拥有内部锁。其他线程会被阻塞，直到锁被释放。

synchronized 使用字节码指令来控制锁：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。

```java
synchronization(同步监视器) {
    // 临界区
```
- 临界区：访问共享数据的代码块。同一时刻只允许一个线程进入临界区。
- 同步监视器：也称为锁，任何一个类的对象都可以充当锁。**多个线程必须共用同一个锁**。

```java
class WindowRunnable implements Runnable {

    private int ticket = 100;
    // 多个线程共享同一把锁
    private Object obj = new Object();

    @Override
    public void run() {
        //Object obj = new Object();
        // 要是 obj 放这里，那每个线程都有不同的锁了，无法同步
        while (true) {
            synchronized (obj) {
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + ": " + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}
class WindowRunnableTest {
    public static void main(String[] args) {
        WindowRunnable w = new WindowRunnable();

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w);

        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
```

```java
class Window extends Thread {

    private static int ticket = 100;
    // 这个锁必须是 static 的，因为每个线程都是不同的 Thread 对象
    private static Object obj = new Object();

    @Override
    public void run() {
        while (true) {
            synchronized (obj) {
                if (ticket > 0) {
                    System.out.println(getName() + ": " + ticket);
                    ticket--;
                } else {
                    break;
                }
            }
        }
    }
}
class WindowThreadTest {
    public static void main(String[] args) {
        Window w1 = new Window();
        Window w2 = new Window();
        Window w3 = new Window();

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }
}
```

为了方便起见，锁可以直接使用 **this 对象** 或者 **getClass() / 类名.class**

### 15.5.2. synchronized 同步方法

如果整个方法都是临界区，不妨把改方法声明为同步方法。
非静态同步方法的锁是 this；静态方法的锁是当前类。

### 15.5.3. 同步锁 Lock ReentrantLock (jdk5.0 新增)

java.util.concurrent.locks.Lock 接口
```java
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
```

ReentrantLock 实现了 Lock 接口
通过构造器参数可以指定使用公平锁还是非公平锁，默认非公平锁。
```java
class WindowRunnable implements Runnable {

    private int ticket = 100;
    private Lock lock = new ReentrantLock(true);

    @Override
    public void run() {
        while (true) {
            lock.lock();
            try {
                if (ticket > 0) {
                    System.out.println(Thread.currentThread().getName() + ": " + ticket);
                    ticket--;
                } else {
                    break;
                }
            } finally {
                lock.unlock();
            }
        }
    }
}
class WindowRunnableTest {
    public static void main(String[] args) {
        WindowRunnable w = new WindowRunnable();

        Thread w1 = new Thread(w);
        Thread w2 = new Thread(w);
        Thread w3 = new Thread(w);

        w1.setName("窗口1");
        w2.setName("窗口2");
        w3.setName("窗口3");

        w1.start();
        w2.start();
        w3.start();
    }
}
```

**重进入 Reentrancy**
![image-20200323183058740](/images/image-20200323183058740.png)
![image-20200323183106399](/images/image-20200323183106399.png)
获得的对象关联的锁并不能阻止其他线程访问这个对象，只能阻止其他线程再获得相同的锁。
每个对象都有一个内部锁。

【面试题】synchronized 和 Lock 的异同？
答：
相同：
1. 可重入锁：synchronized和ReentrantLook都是可重入锁

不同：
1. Synchronized 是隐性锁，自动的获取和释放锁；ReentrantLock 是显性锁，需要自己写获取和释放锁的语句(在try-finally块中释放锁)。
2. synchronized 是非公平锁，它无法保证等待的线程获取锁的顺序；ReentrantLook 可以选择是否公平锁。
3. Synchronized 是不可中断锁，ReentrantLock 可以通过 lockInterruptibly 方法中断等待锁。
4. 底层实现：
    synchronized 使用字节码指令来控制锁：monitorenter和monitorexit。当线程执行遇到monitorenter指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到monitorexit指令时锁计数器-1，如果计数器为0则释放锁。
    ReentrantLock 依靠的是CAS乐观锁，依赖 AbstractQueuedSynchronizer 类，把所有的请求线程构成一个CLH队列。而对该队列的操作均通过Lock-Free（CAS）操作。
5. synchronized锁是读写互斥并且读读也互斥；ReentrantReadWriteLock 分为读锁和写锁，而读锁可以同时被多个线程持有，适合于读多写少场景的并发。

参考：https://www.jianshu.com/p/b343a9637f95

6. synchronized 修饰方法时锁定的是调用该方法的对象。它并不能使调用该方法的多个对象在执行顺序上互斥。

![image-20200402181328804](/images/image-20200402181328804.png) 

【看看题】
![image-20200323182712945](/images/image-20200323182712945.png)
1.synchronzied关键字修饰static方法：该锁由该类持有，相同类只可持有一把锁。
2.synchronzied关键字修饰普通方法：该锁由类对象持有，相同对象只可持有一把锁。

### 15.5.4. 死锁

定义：两个或两个以上的进程/线程，在并发运行的情况下，因为竞争多个互斥资源，而造成它们互相等待对方无法释放的资源的现象，这种现象在无外力的作用时不可解除。

**死锁产生的主要原因**
1. 系统资源不足
2. 进程推进的顺序不合理
3. 资源分配不当

**死锁产生的四个必要条件**
1. 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
2. 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
4. 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

**预防死锁**
1. 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
3. 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
4. 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）

**避免死锁**（一定不会发送死锁）
银行家算法：当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程知道同意该请求后系统状态仍然是安全的。
银行家算法事先得知道所以每个进程需要分配的总的资源数。

参考：https://blog.csdn.net/hd12370/article/details/82814348

## 15.6. 线程通讯

### 15.6.1. PV 操作

```java
int S = 1;

void p() {
    S--;
    if (S < 0) {
        wait();
    }
}

void v() {
    S++;
    if (S <= 0) {
        awake();
    }
}
```

进程的同步、互斥、通信的区别，进程与线程同步的区别：https://blog.csdn.net/weixin_41413441/article/details/80548683

**利用信号量和PV操作实现进程互斥的一般模型**
```text
S = 1;
进程P1              进程P2           ……          进程Pn
……                  ……                           ……
P（S）；             P（S）；                     P（S）；
临界区；             临界区；                     临界区；
V（S）；             V（S）；                     V（S）；
……                  ……              ……           ……
```

参考：https://www.cnblogs.com/litaoyang/p/6606499.html


### 15.6.2. 两个线程交替打印 1~100

wait()：执行改方法的线程进入阻塞状态，并释放同步监视器
notify()：唤醒一个被wait的线程，多个线程按照优先级最高的被唤醒
notifyAll()：唤醒所有被wait的线程

上面这三个方法都必须在 synchronized 块中出现，否则会抛出 java.lang.IllegalMonitorStateException 异常
并且 synchronized(xxx) 的同步监视器必须和 xxx.wait() 的同步监视器相同

#### 15.6.2.1. 【面试题】sleep 和 wait 的异同？
相同：
    1. 两个方法执行都会使当前线程进入阻塞状态
    2. wait 和 sleep 都可以通过 interrupt() 方法打断线程的暂停状态 
不同：
    1. sleep 是 Thread 的 static 方法；wait 是 Object 的 final 方法
    2. wait 只能在同步代码块中，通过同步监视器来调用；sleep 随时可以通过 Thread 类来调用
    3. 在同步代码块中，sleep 不会释放锁；wait 会 释放锁
    4. sleep 必须指定时间，wait 可以指定也可以不指定，通过 notify 来唤醒

```java
class Pint implements Runnable {
    private int number = 1;
    private Object obj = new Object();

    @Override
    public void run() {
        boolean flag = true;
        while (flag) {
            // 刚开始运行时，两个线程去抢夺锁
            // 抢到锁的先执行
            synchronized (obj) {
                if (number <= 100) {
                    System.out.println(Thread.currentThread().getName() + ":" + number);
                    number++;
                } else {
                    flag = false;
                }

                // 干完活后，叫醒别人，阻塞自己

                // 线程打印完之后，就唤醒其他线程
                // 因为当前线程已经拿到锁了，所以其他线程也不会立马进入
                obj.notify();

                // 如果活都干完了，就直接推出，不需要阻塞了
                if (!flag) {
                    break;
                }

                // 如果还有活，就阻塞自己，等待另一个线程干完活唤醒自己
                // wait 会释放锁的，此时其他线程就可以进入了
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
public class ThreadCommunication {
    public static void main(String[] args) {
        Runnable pint = new Pint();
        Thread t1 = new Thread(pint);
        Thread t2 = new Thread(pint);
        t1.setName("线程一");
        t2.setName("线程二");
        t1.start();
        t2.start();
    }
}
```

### 15.6.3. 生产者消费者问题

![](/images/生产者消费者问题.png)

1. 是否是多线程问题？ 是，生产者线程若干，消费者线程若干
2. 是否有共享数据？ 是，产品
3. 是否涉及到线程安全问题？ 是，多个生产者同时存放产品，多个消费者同时消费产品
4. 是否涉及到线程通讯？ 是，产品存放区有空间则唤醒生产者，存放区有产品则唤醒消费者

```java
/**
 * 店员，产品缓存区
 */
class Clerk {

    private static final int MAX_NUM = 2;
    private int productNum = 0;

    public synchronized void add() {
        if (productNum < MAX_NUM) {
            productNum++;
            System.out.println(Thread.currentThread().getName() + "提供一个产品，放入" + productNum + "号区");
            // 唤醒消费者
            notify();
        } else {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public synchronized void del() {
        if (productNum > 0) {
            System.out.println(Thread.currentThread().getName() + "拿走" + productNum + "号区的一个产品");
            productNum--;
            // 唤醒生产者
            notify();
        } else {
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
/**
 * 生产者
 */
class Producer extends Thread {
    private Clerk clerk;

    public Producer(Clerk clerk){
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println("----"+getName()+"来了----");
        while (true) {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //System.out.println(getName() + ": 生产了一件产品");
            clerk.add();
        }
    }
}

/**
 * 消费者
 */
class Customer extends Thread {
    private Clerk clerk;

    public Customer(Clerk clerk){
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println("----"+getName()+"来了----");
        while (true) {
            clerk.del();
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //System.out.println(getName() + ": 消费了一件产品");
        }
    }
}

/**
 * 生产者消费者问题
 *
 * @author aBadString
 * @date 2020-08-07 13:32:41
 */
public class ProductorCustomer {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();
        Producer producer = new Producer(clerk);
        Customer customer = new Customer(clerk);
        producer.setName("生产者1");
        customer.setName("消费者1");
        Customer customer2 = new Customer(clerk);
        customer2.setName("消费者2");


        customer.start();
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        producer.start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        customer2.start();
    }
}
```

### 15.6.4. 再探生产者消费者模型（基本模板）

线程操作资源类，高内聚低耦合
判断 干活 通知
防止虚假唤醒机制

模板：
```java
// 1、synchronized - wait - notify
private volatile int num = 0;
public void addOne() throws Exception {
    // 0、加锁
    synchronized (this) {
        // 1、判断，不满足干活条件就阻塞
        // 用 while 而不用 if：防止虚假唤醒机制
        while (num != 0) {
            this.wait();
        }
        // 2、干活
        num++;
        System.out.println(Thread.currentThread().getName() + " " + num);
        // 3、干完活唤醒其他线程
        this.notify();
    }
    // 0、解锁
}

// 2、lock/unlock - await - signal
private volatile int num = 0;
private Lock lock = new ReentrantLock();
private Condition condition = lock.newCondition();
public void addOne() throws Exception {
    // 0、加锁
    lock.lock();
    try {
        // 1、判断，不满足干活条件就阻塞
        while (num != 0) {
            condition.await();
        }
        // 2、干活
        num++;
        System.out.println(Thread.currentThread().getName()+" "+num);
        // 3、干完活唤醒其他线程
        condition.signal();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        // 0、解锁
        lock.unlock();
    }
}
```


# 16. 泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了**编译时**类型安全检测机制，该机制允许程序员在**编译时**检测到非法的类型。
泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

## 16.1. 泛型方法

- 在方法的返回值前面，在尖括号中可以声明类型参数，多个类型参数用逗号隔开。
- 类型参数必须先声明后使用。
- 类型参数只能代表引用型类型，不能是基本数据类型。

```java
// 泛型方法 printArray
public static < E > void printArray( E[] inputArray )
{
    // 输出数组元素
    for ( E element : inputArray ){
        System.out.printf( "%s ", element );
    }
    System.out.println();
}
public static void main( String args[] )
{
    // 创建不同类型数组： Integer, Double 和 Character
    Integer[] intArray = { 1, 2, 3, 4, 5 };
    Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
    Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };

    System.out.println( "整型数组元素为:" );
    printArray( intArray  ); // 传递一个整型数组

    System.out.println( "\n双精度型数组元素为:" );
    printArray( doubleArray ); // 传递一个双精度型数组

    System.out.println( "\n字符型数组元素为:" );
    printArray( charArray ); // 传递一个字符型数组
}
```

- `<? extends T>` 表示该通配符所代表的类型是 T 类型的子类。
- `<? super T>` 表示该通配符所代表的类型是 T 类型的父类。

## 16.2. 类型擦除

`List<String>、List<T>` 擦除后的类型为 `List`。
`List<String>[]、List<T>[]` 擦除后的类型为 `List[]`。
`List<? extends E>、List<? super E>` 擦除后的类型为 `List<E>`。
`List<T extends Serialzable & Cloneable>` 擦除后类型为 `List<Serializable>`。


# 17. 集合

![img](/images/集合.gif)

集合有关的类和接口均在 java.util 包下 

**集合有关的接口：**

- Collection 接口：集合类的根接口，没有这个接口的直接实现类。
  - List 接口：有序的集合，可以包含重复的元素，提供了按索引访问的方式。
    - ArrayList - 线程安全 Collections.synchronizedList()
    - LinkedList
    - Vector
  - Set 接口：不能包含重复的元素。
    - HashSet
      - LinkedHashSet
    - TreeSet
  
- Map 接口：Map不能包含重复的key，但是可以包含相同的value。
  - HashMap
    - LinkedHashMap
  - TreeMap
  - ConcurrentHashMap
  - Hashtable
    - Properties

- Iterator 接口：所有的集合类都实现了它，这是一个用于遍历集合中元素的接口。
  > hasNext() 是否还有下一个元素。
  > next() 返回下一个元素。
  > remove() 删除当前元素。

综上：List（有序可重复）、Set（无序不能重复）、Map（键值对：键唯一，值可重复）

## 17.1. List

![](/images/ArrayListVectorLinkedList.png)

**ArrayList**
- 底层基于数组，默认初始化长度为 10，每次增长当前数组长度的一半
- 1.8 以后，只有当第一次 add 的时候才会初始化数组。
- ArrayList不适合做队列。

**LinkedList**
- 底层是双向链表
- 可以当作堆、栈、队列、双向队列使用

**ArrayList和LinkedList**
- ArrayList 和 LinkedList在用法上没有区别，但是在功能上还是有区别的。
- ArrayList的底层是数组，LinkedList的底层是双向链表。
- **一般来说ArrayList的访问速度是要比LinkedList要快的。一般来说LinkedList的增删速度是要比ArrayList要快的**
- LinkedList 经常用在增删操作较多而查询操作很少的情况下，ArrayList则相反。
- ArrayList 继承 AbstractList 实现 List
  ```java
  public class ArrayList<E> 
      extends AbstractList<E>
      implements List<E>, RandomAccess, Cloneable, java.io.Serializable
  ```
- LinkedList 继承 AbstractSequentialList 实现 List
  ```java
  public class LinkedList<E>
      extends AbstractSequentialList<E>
      implements List<E>, Deque<E>, Cloneable, java.io.Serializable
  ```

**ArrayList和Vector**
```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
相同点：
​    1、都实现了 List 接口
​    2、都是有序的集合
​    3、底层都是数组
​    4、按位置索引取出某个元素
​    5、允许重复元素
​    6、允许元素为 null
不同点：
​    1、ArrayList是非同步的；Vector是同步的。可以使用Collections工具类来构建出同步的ArrayList。
​    2、Vector 每次增长原来的一倍，ArrayList 每次增长原来的0.5倍。

## 17.2. Set

HashSet、TreeSet、LinkedHashSet
所有的 Set 都是基于 Map 实现的。

- TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 $o(1)$，TreeSet 则为 $o(log n)$。
- HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
- LinkedHashSet：具有 HashSet 的查找效率，并且内部使用双向链表维护元素的插入顺序。

Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用==还是equals()
答：都用，== 或者 equals
```java
// 1. 如果key 相等  
if (p.hash == hash &&
    ((k = p.key) == key || (key != null && key.equals(k))))
    e = p;
// 2. 修改对应的value
if (e != null) { // existing mapping for key
    V oldValue = e.value;
    if (!onlyIfAbsent || oldValue == null)
        e.value = value;
    afterNodeAccess(e);
    return oldValue;
}
```

### 17.2.1. HashSet

![HashMap的UML图](/images/1.png) 

HashSet内部基本使用HashMap来实现。HashMap的key为要存储的元素，value为一个固定的 Object 常量。
```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable
{
    static final long serialVersionUID = -5024744406713321676L;
    private transient HashMap<E,Object> map;
    private static final Object PRESENT = new Object();
}
```

构造器
```java
public HashSet() {
    map = new HashMap<>();
}
// 构造一个包含指定Collection中的元素的新set，容器大小为Collection大小的4/3倍，和16的最大值
public HashSet(Collection<? extends E> c) {
    map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
    addAll(c);
}
// 传入初始容量和负载因子，构造一个空的HashSetLinkedHashMap
public HashSet(int initialCapacity, float loadFactor) {
    map = new HashMap<>(initialCapacity, loadFactor);
}
// 传入初始容量，构造一个空的HashSetLinkedHashMap
public HashSet(int initialCapacity) {
    map = new HashMap<>(initialCapacity);
}
// 传入初始容量、加载因子和标记，构造一个空的LinkedHashMap，此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持。
HashSet(int initialCapacity, float loadFactor, boolean dummy) {
    map = new LinkedHashMap<>(initialCapacity, loadFactor);
}
```

## 17.3. Map

![](/images/HashMapHashTableTreeMap.png)
![](/images/Map.png)

HashMap、Hashtable、LinkedHashMap、TreeMap、ConcurrentHashMap。
```
Map 接口：Map不能包含重复的key，但是可以包含相同的value。
 |-- HashMap
        |-- LinkedHashMap
 |-- TreeMap
 |-- ConcurrentHashMap
 |-- Hashtable
        |-- Properties
```

- HashMap 数组(哈希表)+链表/红黑树
  HashMap是最常用的Map，它根据键的HashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度 o(1)。遍历时，取得数据的**顺序是完全随机**的。因为键对象不可以重复，所以HashMap最多**只允许一条记录的键为null**，允许多条记录的值为null，是**非同步的**。

- Hashtable
  Hashtable与HashMap类似，是**HashMap的线程安全版**，它支持线程的同步。HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，锁粒度比较大。即任一时刻只有一个线程能写Hashtable，因此也导致了Hashtale在**写入时会比较慢**，它继承自Dictionary类，不同的是**它不允许记录的键或者值为null**，同时效率较低。

- ConcurrentHashMap
  ConcurrentHashMap使用**分段锁**，降低了锁粒度，让并发度大大提高。**线程安全**，并且锁分离。ConcurrentHashMap内部使用段(Segment)来表示这些不同的部分，**每个段其实就是一个小的hash table**，它们有自己的锁。**只要多个修改操作发生在不同的段上，它们就可以并发进行**。

- LinkedHashMap
  LinkedHashMap **是有序的**，内部使用一个**链表**，有头尾节点。LinkedHashMap保存了**记录的插入顺序**，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的，在遍历的时候会比HashMap慢，有HashMap的全部特性。
  使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。
  适合频繁遍历的场景（具体场景？？？）。

- TreeMap 基于红黑树实现
  TreeMap实现SortMap接口，能够把它保存的记录**根据键排序**，默认是按键值的升序排序（自然顺序），也可以**指定排序的比较器**，当用Iterator遍历TreeMap时，得到的记录是排过序的。不允许key值为空，**非同步的**。

**HashMap和Hashtable的区别**
1、HashMap是非同步的；Hashtable是同步的
2、HashMap允许 最多一个 key 为null，V 随意；Hashtable不允许 K 和 V为null
3、Hashtable有contains方法；HashMap 把Hashtable的contains方法去掉了，改成了containsValue和containsKey
4、继承的父类不同
```java
public class HashMap<K,V> 
    extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {}
public class Hashtable<K,V>
    extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable {}
```

### 17.3.1. HashMap（面试的重点）

> 参考文献
> [一个HashMap跟面试官扯了半个小时](https://zhuanlan.zhihu.com/p/125628540)
> [Java 8系列之重新认识HashMap](https://zhuanlan.zhihu.com/p/21673805)
> [用漫画告诉你—什么是HashMap？](https://zhuanlan.zhihu.com/p/78079598)

> 前置要求：
> 1. [数据结构与算法 1.5. 散列表](/04_计算机基础理论/01_数据结构与算法.md#15-散列表)
> 2. [两数之和（一次遍历+HashMap）](/04_计算机基础理论/01_数据结构与算法.md#34-两数之和一次遍历hashmaphttpsleetcode-cncomproblemstwo-sum)


HashMap 是一个散列表，存储着键值对映射。
> 以下源码均出自 JDK1.8

```java
public class HashMap<K,V> 
    extends AbstractMap<K,V> 
    implements Map<K,V>, Cloneable, Serializable 
```
Map 是 key-value 键值对接口
AbstractMap 实现了键值对的通用函数接口
它是线程不安全的，key 和 value 都可以为 null，并且它是无序的。


#### 17.3.1.1. 重要属性和常量
属性：
- loadFactor 负载因子   0.75
- threshold  扩容极限   24 = loadFactor * table.length
- size       键值对数量 >= 12
- modCount   修改次数
- table      散列数组   32
```java
/**
 * The next size value at which to resize (capacity * load factor).
 * 超过 threshold 则需要进行扩容
 * threshold = length(数组长度) * loadFactor
 */
// (The javadoc description is true upon serialization.
// Additionally, if the table array has not been allocated, this
// field holds the initial array capacity, or zero signifying
// DEFAULT_INITIAL_CAPACITY.)
int threshold;

/**
 * The load factor for the hash table.
 * 负载因子
 * 被 final 所修饰，只能赋值一次（构造器）
 */
final float loadFactor;

/**
 * The number of key-value mappings contained in this map.
 */
transient int size;

/**
 * 修改次数
 * 快速失效 fail-fast
 * 与 ConcurrentModificationException 有关
 */
transient int modCount;

/**
 * The table, initialized on first use, and resized as
 * necessary. When allocated, length is always apower of two.
 * (We also tolerate length zero in some operations to allow
 * bootstrapping mechanics that are currently not needed.)
 */
transient Node<K,V>[] table;
```
负载因子默认值是 0.75（是对空间和时间效率的一个平衡选择）
如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；
相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，这个值可以大于1。

常量：
- DEFAULT_INITIAL_CAPACITY 默认初始容量 16
- DEFAULT_LOAD_FACTOR      默认负载因子 0.75f
- MAXIMUM_CAPACITY         最大容量
```java
/**
 * The default initial capacity - MUST be a power of two.
 * 默认初始容量
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

/**
 * The load factor used when none specified in constructor.
 * 默认负载因子
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
/**
 * The maximum capacity, used if a higher value is implicitly specified
 * by either of the constructors with arguments.
 * MUST be a power of two <= 1<<30.
 *
 * int 所能表示的最大的二次幂
 * 1073741824
 * 0100 0000 0000 0000 0000 0000 0000 0000
 */
static final int MAXIMUM_CAPACITY = 1 << 30;
```

#### 17.3.1.2. 构造器 (4个)
**两个参数：初始容量和负载因子。**
容量是HashMap中桶的数量；负载因子是HashMap在其容量自动增加之前可以达到多满的一种尺度。当键值对的数量超过负载因子与当前容量之积（即使用了百分之多少的桶），就要对HashMap进行 rehash 操作（重建内部数据结构），重建之后HashMap将具有之前两倍的桶数目。

**【HashMap怎么设定初始容量大小】**
默认初始容量大小是16，负载因子是 0.75。
如果传入初始容量 n，则初始容量设定为 大于等于 n 的 2的整数次幂。

```java
// 指定“容量大小”和“负载因子”的构造函数
/**
 * 使用指定的初始容量和负载因子构造一个空的HashMap.
 * @param  initialCapacity 初始容量.
 * @param  loadFactor 负载因子.
 * @throws IllegalArgumentException 如果初始容量为负，或负载因子为非正.
 */
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " + loadFactor);

    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}

// 指定“容量大小”的构造函数
/**
 * 使用指定的初始容量和默认的负载因子(0.75)构造一个空的HashMap.
 * @param initialCapacity 初始容量.
 * @throws IllegalArgumentException 如果初始容量是负的.
 */
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

// 默认空参构造函数.
/**
 * 使用默认初始容量(16)和默认负载因子(0.75)构造一个空的Hashmap.
 */
public HashMap() {
    // 负载因子 = 0.75f
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    // 所有其他字段默认
    // threshold 的值不给力嘛？？？
}

// 包含“子Map”的构造函数
/**
 * 使用与指定映射相同的映射构造新的HashMap。HashMap是使用默认的负载因子(0.75)和足够容纳指定映射的初始容量创建的.
 * @param   m the map whose mappings are to be placed in this map
 * @throws  NullPointerException 如果指定的映射为空.
 */
public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
```

**最接近的二次幂**
```java
/**
 * Returns a power of two size for the given target capacity.
 * 返回大于或等于 cap 的最小二次幂
 */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1; // n = n | (n >>> 1)
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

解释：
|||
|-|-|
|`cap = 50`    | 0011 0010     |
|`n = cap - 1` | 00==1==1 0001 |
|`n >>> 1`     | 000==1== 1000 |
|`n |= n >>> 1`| 00==11== 1001 |
|`n >>> 2`     | 0000 ==11==10 |
|`n |= n >>> 2`| 00==11 11==11 |
|||
|`n + 1`| 0==1==00 0000 |
|`return`| 0==1==00 0000 |

|||
|-|-|
|`cap = MAXIMUM_CAPACITY + 1`| 01000000000000000000000000000001 |
|`n = cap - 1`               | 01000000000000000000000000000000 |
|`n >>> 1`                   | 00100000000000000000000000000000 |
|`n |= n >>> 1`              | 01100000000000000000000000000000 |
|`n >>> 2`                   | 00011000000000000000000000000000 |
|`n |= n >>> 2`              | 01111000000000000000000000000000 |
|`n >>> 4`                   | 00000111100000000000000000000000 |
|`n |= n >>> 4`              | 01111111100000000000000000000000 |
|`n >>> 8`                   | 00000000011111111000000000000000 |
|`n |= n >>> 8`              | 01111111111111111000000000000000 |
|`n >>> 16`                  | 00000000000000000111111111111111 |
|`n |= n >>> 16`             | 01111111111111111111111111111111 |
|`n + 1`                     | 10000000000000000000000000000000 |
|`return`                    | 01000000000000000000000000000000 |

```java
System.out.println(MAXIMUM_CAPACITY);   // 1073741824

System.out.println(tableSizeFor(-10));  // 1
System.out.println(tableSizeFor(0));    // 1
System.out.println(tableSizeFor(100));  // 128
System.out.println(tableSizeFor(1023)); // 1024
System.out.println(tableSizeFor(1025)); // 2048
System.out.println(tableSizeFor(4096)); // 4096
```
【笔试题】
> [快手2020校园招聘秋招笔试--工程C试卷 第2题](https://www.nowcoder.com/profile/208088206/test/37559227/907607#summary)
> ![](/images/tableSizeFor.png)
> 注意 return 少个 +1

`>>` 右移：规则是低位移出，高位补符号位。正数 0，负数 1
`>>>` 无符号右移：高位始终补0。

#### 17.3.1.3. 哈希函数
Hash(x) = (x.hashCode()>>>16 ^ x.hashCode()) % n;

设计要点
- 扰动函数：尽可能降低hash碰撞，越分散越好；
- 算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；

1. 取 key 的 hashcode()（如果 null -> 0）
2. 将 hash 值的高 16 位与 hash 进行异或操作
3. hash 对数组长度取余，得到应该存放的下标

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
// 详细写
// static final int hash(Object key) {
//     if (key == null) {
//         return 0;
//     }
//     int h = key.hashCode();
//     int tem = h >>> 16;
//     return h ^ tem;
// }
```
```java
// jdk 1.7 中有该函数
// jdk 1.8 被删除了
bucketIndex = indexFor(hash, table.length);
static int indexFor(int h, int length) {
    return h & (length-1);
    // h % length  ==  h & (length-1)
}
// jdk 1.8 的操作
tab[i = (n - 1) & hash])
```

**【HashMap 为啥桶大小（数组长度）必须为 $2^n$】**
**将取余运算转化为位运算。**
1. 提升计算效率，更快算出元素的位置
  取余操作转化为异或操作（`x % length == x & (length-1)`，$length = 2^n$）
2. <s>减少哈希碰撞，使得元素分布均匀
  2的n次幂永远是偶数，length-1最后一位是 1。进行 & 操作后，会保留原数 x 的最后一位，即保留 x 的奇偶性。
  如果 length 为奇数的话，length-1最后一位是 0。& 操作后，无论奇数偶数都会映射到偶数位置上，而奇数位置上没有元素。</s>
（我觉得第二点是瞎扯，不过 使得元素分布均匀 还是有些道理）
3. 扩容后，rehash操作，节点位置要么保持不变，要么向后移动原来数组大小。

#### 17.3.1.4. 数据结构
jdk 1.8 ：内部使用数组 + 链表/红黑树
![img](https://pic3.zhimg.com/80/v2-4ce38fd1c36fc61e70d7687fae997e5a_720w.jpg) 
当链表长度大于 8 且 数组长度大于等于 64 时，转为红黑树；当红黑树节点小于 6 时，转为链表。

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public final K getKey()        { return key; }
    public final V getValue()      { return value; }
    public final String toString() { return key + "=" + value; }

    public final int hashCode() {
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    }

    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }

    public final boolean equals(Object o) {
        if (o == this)
            return true;
        if (o instanceof Map.Entry) {
            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
            if (Objects.equals(key, e.getKey()) &&
                Objects.equals(value, e.getValue()))
                return true;
        }
        return false;
    }
}
```
关键信息：
```java
final int hash; // 经 hash(key) 计算后的值
final K key;
V value;
Node<K,V> next; // 链表 next 指针
```

#### 17.3.1.5. public V put(K key, V value) 插入/更新
**HashMap的数据插入原理**
1. 判断数组是否为空。
   1. 为空，则初始化数组（resize 扩容）
   2. 不为空，继续。
2. 计算 key 的 hash 值，通过`(n - 1) & hash`计算应当存放在数组中的下标 index
3. 判断该位置是否存在数据
   1. 不存在，则放置要插入的数据。
   2. 存在，继续
4. 判断 key 值是否相等
   1. 相等，更新 value。
   2. 不相等，继续 
5. 查看当前位置是红黑树还是链表
   1. 是红黑树，则放入红黑树节点
   2. 是链表，则加入链表中
6. 链表则要判断是否要转为红黑树。
7. 判断是否需要扩容。
<!-- ![](https://pic4.zhimg.com/80/v2-ff5fe3aac820fafb4cf34b2a801877cf_720w.jpg) -->
![](https://pic3.zhimg.com/80/58e67eae921e4b431782c07444af824e_720w.png)

**为什么 JDK 1.7 采用单链表的头插法？**
根据局部性原理，最近插入的数据被访问可能性更大。（和操作系统中页面调度的 LRU 算法异曲同工之妙）
**头插法的坏处**：在扩容时会改变链表中元素原本的顺序，会使链表发生反转，多线程环境下会产生**环**。

#### 17.3.1.6. final Node<K,V>[] resize() 扩容

1. 新建一个原来两倍大小的数组
2. 遍历旧数组
3. 重新计算每个元素的下标
4. 将每个元素转移到新数组中
5. 用新数组替换旧数组
6. 重设 threshold

因为 HashMap 的数组长度必须为 $2^n$。所有，扩容时rehash操作，节点位置要么保持不变，要么向后移动原来数组大小。

oldIndex = (oldLength - 1) & hash
newIndex = (newLength - 1) & hash
||||||
|-|-|-|-|-|
|hash            | 0000 0101 ||hash            | 000==0== 0101 |
|oldLength-1 (15)| 0000 1111 ||newLength-1 (31)| 000==1== 1111 |
|oldIndex        | 0000 0101 ||newIndex        | 000==0== 0101 (不变)|
||||||
|hash            | 0001 1101 ||hash            | 000==1== 0101 |
|oldLength-1 (15)| 0000 1111 ||newLength-1 (31)| 000==1== 1111 |
|oldIndex        | 0000 0101 ||newIndex        | 000==1== 0101 (加16)|

#### 17.3.1.7. public V get(Object key) 查询

1. 通过 hash() 计算 key 的 hash 值，再计算下标
2. 在给定下标处查找链表或红黑树
3. 调用 key.equals(k) 查找元素

```java
class Person {

}
class Student {
    private int age;

    public Student(int age) {
        this.age = age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age;
    }

    @Override
    public int hashCode() {
        return Objects.hash(age);
    }
}

public class HashMapGet {
    public static void main(String[] args) {
        Map<Person, String> personHashMap = new HashMap<Person, String>();
        personHashMap.put(new Person(), "person");
        
        System.out.println(personHashMap.get(new Person())); // null

        Person p = new Person();
        personHashMap.put(p, "person");
        System.out.println(personHashMap.get(p)); // person


        System.out.println("--------------");
        HashMap<Student, String> studentStringHashMap = new HashMap<>();
        Student s = new Student(18);
        studentStringHashMap.put(s, "student");

        System.out.println(studentStringHashMap.get(s)); // student
        System.out.println(studentStringHashMap.get(new Student(18))); // student

        s.setAge(20);
        System.out.println(studentStringHashMap.get(s)); // null

        System.out.println(studentStringHashMap.get(new Student(18))); // null
        System.out.println(studentStringHashMap.get(new Student(20))); // null


        System.out.println("--------------");
        HashMap<Integer, String> integerStringHashMap = new HashMap<>();
        integerStringHashMap.put(new Integer(1), "1");
        System.out.println(integerStringHashMap.get(new Integer(1)));
    }
}
```

**什么样的数据类型（类）可以作为 Key?**
1. 重写 hashcode 和 equals 方法，且遵循以下原则：equals 相等 -> hashcode 一定相等。
2. 该类的对象具有不可变性（否则会丢失这个键值对，造成内存泄漏）。或者成员变量的改变不会引起 hashcode 的改变，以及 equals 的结果。

#### 17.3.1.8. 面试题

**jdk 1.8 后的改进**
1. 数组+链表 改进为 数组+链表/红黑树
2. 链表插入方式 头插法 改进为 尾插法
3. 插入数据时，1.7 先判断是否要扩容，再插入；1.8 先插入，再判断
4. 1.7 扩容时需要对原数组的元素重新进行 哈希定位；1.8 则要么位置不变，要么向后移动一个旧容量大小。

好处？
1. 使用红黑树：防止发生hash冲突，链表长度过长，将时间复杂度由`O(n)`降为`O(logn)`
2. 头插法,在扩容时会改变链表中元素原本的顺序，会使链表发生反转，多线程环境下会产生环；而尾插法不会成环

**HashMap是线程安全的吗？**
不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题。
线程安全的：Hashtable、ConcurrentHashMap、Collections.synchronizedMap
- HashTable是直接在操作方法上加synchronized关键字，锁住整个数组，锁粒度比较大。
- Collections.synchronizedMap是使用Collections集合工具的内部类，通过传入Map封装出一个SynchronizedMap对象，内部定义了一个对象锁，方法通过对象锁实现线程安全。
- ConcurrentHashMap使用分段锁，降低了锁粒度，让并发度大大提高。

**HashMap内部节点是有序的吗？**
是无序的，根据hash值随机插入
LinkedHashMap 是有序的，内部使用一个链表，有头尾节点。
同时LinkedHashMap节点Entry内部除了继承HashMap的Node属性，还有before 和 after用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。


### 17.3.2. ConcurrentHashMap（jdk 1.7 源码）

```java
//默认的数组大小16(HashMap里的那个数组)
static final int DEFAULT_INITIAL_CAPACITY = 16;

//扩容因子0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;

//ConcurrentHashMap中的数组
final Segment<K,V>[] segments;

//默认并发标准16
static final int DEFAULT_CONCURRENCY_LEVEL = 16;

//Segment是ReentrantLock子类，因此拥有锁的操作
static final class Segment<K,V> extends ReentrantLock implements Serializable {
    //HashMap的那一套，分别是数组、键值对数量、阈值、负载因子
    transient volatile HashEntry<K,V>[] table;
    transient int count;
    transient int threshold;
    final float loadFactor;

    Segment(float lf, int threshold, HashEntry<K,V>[] tab) {
        this.loadFactor = lf;
        this.threshold = threshold;
        this.table = tab;
    }
}

//换了马甲还是认识你！！！HashEntry对象，存key、value、hash值以及下一个节点
static final class HashEntry<K,V> {
    final int hash;
    final K key;
    volatile V value;
    volatile HashEntry<K,V> next;
}
//segment中HashEntry[]数组最小长度
static final int MIN_SEGMENT_TABLE_CAPACITY = 2;

//用于定位在segments数组中的位置，下面介绍
final int segmentMask;
final int segmentShift;
```

**构造器：**
```java
public ConcurrentHashMap() {
    this(
        DEFAULT_INITIAL_CAPACITY, 
        DEFAULT_LOAD_FACTOR,     
        DEFAULT_CONCURRENCY_LEVEL
    );
}

public ConcurrentHashMap(
    int initialCapacity,
    float loadFactor, 
    int concurrencyLevel
) {
    if (!(loadFactor > 0) || initialCapacity < 0 || concurrencyLevel <= 0)
        throw new IllegalArgumentException();
    if (concurrencyLevel > MAX_SEGMENTS)
        concurrencyLevel = MAX_SEGMENTS;
    // Find power-of-two sizes best matching arguments
    //步骤① start
    int sshift = 0;
    int ssize = 1;
    while (ssize < concurrencyLevel) {
        ++sshift;
        ssize <<= 1;
    }
    this.segmentShift = 32 - sshift;
    this.segmentMask = ssize - 1;
    //步骤① end
    //步骤② start
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    int c = initialCapacity / ssize;
    if (c * ssize < initialCapacity)
        ++c;
    int cap = MIN_SEGMENT_TABLE_CAPACITY;
    while (cap < c)
        cap <<= 1;
    //步骤② end
    // create segments and segments[0]
    //步骤③ start
    Segment<K,V> s0 =
        new Segment<K,V>(loadFactor, (int)(cap * loadFactor),
                         (HashEntry<K,V>[])new HashEntry[cap]);
    Segment<K,V>[] ss = (Segment<K,V>[])new Segment[ssize];
    UNSAFE.putOrderedObject(ss, SBASE, s0); // ordered write of segments[0]
    this.segments = ss;
    //步骤③ end
}
// 作者：HuYounger
// 链接：https://juejin.im/post/5a2f2f7851882554b837823a
```

 **put 方法：**
```java
public V put(K key, V value) {
    Segment<K,V> s;
    //步骤①注意valus不能为空！！！
    if (value == null)
        throw new NullPointerException();
    //根据key计算hash值，key也不能为null，否则hash(key)报空指针
    int hash = hash(key);
    //步骤②派上用场了，根据hash值计算在segments数组中的位置
    int j = (hash >>> segmentShift) & segmentMask;
    //步骤③查看当前数组中指定位置Segment是否为空
    //若为空，先创建初始化Segment再put值，不为空，直接put值。
    if ((s = (Segment<K,V>)UNSAFE.getObject // nonvolatile; recheck
         (segments, (j << SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
}

// 作者：HuYounger
// 链接：https://juejin.im/post/5a2f2f7851882554b837823a
```

**ensureSegment() 方法：**
```java
private Segment<K,V> ensureSegment(int k) {
    //获取segments
    final Segment<K,V>[] ss = this.segments;
    long u = (k << SSHIFT) + SBASE; // raw offset
    Segment<K,V> seg;
    if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u)) == null) {
        //拷贝一份和segment 0一样的segment
        Segment<K,V> proto = ss[0]; // use segment 0 as prototype
        //大小和segment 0一致，为2
        int cap = proto.table.length;
        //负载因子和segment 0一致，为0.75
        float lf = proto.loadFactor;
        //阈值和segment 0一致，为1
        int threshold = (int)(cap * lf);
        //根据大小创建HashEntry数组tab
        HashEntry<K,V>[] tab = (HashEntry<K,V>[])new HashEntry[cap];
        //再次检查
        if ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
            == null) { // recheck
            根据已有属性创建指定位置的Segment
                Segment<K,V> s = new Segment<K,V>(lf, threshold, tab);
            while ((seg = (Segment<K,V>)UNSAFE.getObjectVolatile(ss, u))
                   == null) {
                if (UNSAFE.compareAndSwapObject(ss, u, null, seg = s))
                    break;
            }
        }
    }
    return seg;
}
```

**jdk 7 ConcurrentHashMap put 流程**
![img](https://user-gold-cdn.xitu.io/2017/12/12/1604851702c89293?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


### 17.3.3. TreeMap

#### 17.3.3.1. 红黑树
**红黑树：**
0. 满足二叉查找树
1. 节点是红色或者黑色
2. 根节点是黑色
3. 每个叶子节点都是黑色的空节点（NIL 节点）
4. 每个红色节点的两个子节点都是黑色（从每个叶子到根的路径不能有两个连续的红色节点）
5. 从任何一个节点到其每个叶子节点的所用路径包含相同数目的黑色节点

![image-20200403175646744](/images/image-20200403175646744.png)

这些规则的限定，保证了红黑树的自平衡。红黑树从根节点到叶子的最长路径不会超过最短路径的 2 倍。

**调整** https://juejin.im/post/5a27c6946fb9a04509096248
1. 变色
2. 旋转
   - 左旋转
   - 右旋转

#### 17.3.3.2. TreeMap 源码

![img](/images/TreeMap.png)

- TreeMap实现了NavigableMap接口，而NavigableMap接口继承着SortedMap接口，致使我们的**TreeMap是有序的**
- TreeMap底层是红黑树，它方法的时间复杂度：log(n)
- **非同步**
- 使用Comparator或者Comparable来比较key是否相等与排序的问题

- TreeMap底层是红黑树，集合有序线程不安全。
- 若比较器为空则key一定不能为null，若比较器不为空则key可以为null由TreeMap其比较器而定
- containsValue方法采用中序遍历(LDR左根右)方式遍历整个TreeMap

**TreeMap 重要字段**
```java
// 比较器用于排序，若为null使用自然排序维持key顺序 
private final Comparator comparator; 

// 根节点
// java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。
private transient Entry root;

// 节点数
private transient int size = 0;

// 修改次数，fail-fast
private transient int modCount = 0;

//节点颜色
private static final boolean RED   = false;
private static final boolean BLACK = true;

/**
 * 节点
 */
static final class Entry implements Map.Entry {
    K key;                    //键
    V value;                  //值    
    Entry left;               //左子树
    Entry right;              //右子树
    Entry parent;             //父亲
    boolean color = BLACK;    //颜色

    Entry(K key, V value, Entry parent) {...}

    public K getKey() {...}

    public V getValue() {...}

    public V setValue(V value) {...}

    public boolean equals(Object o) {...}

    public int hashCode() {...}

    public String toString() {...}
}

```

**构造器**
```java
/**
 * 无参构造，自然排序(从小到大)。要求key实现Comparable接口，会调用key重写的compareTo方法进行比较
 * 若key没有实现comparable接口，运行时报错(java.lang.ClassCastException)
 */
public TreeMap() {
    comparator = null;
}

/**
 * 指定比较器，若不为null会调用其compare方法进行比较，无需键实现comparable接口
 */
public TreeMap(Comparator comparator) {
    this.comparator = comparator;
}

/**
 * 将map转为treeMap，比较器为null，注意key
 */
public TreeMap(Map m) {
    comparator = null;
    putAll(m);
}

/**
 * 将map转为treeMap，比较器为SortMap中的comparator
 */
public TreeMap(SortedMap m) {
    comparator = m.comparator();
    try {
        buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
    } catch (java.io.IOException cannotHappen) {
        
    } catch (ClassNotFoundException cannotHappen) {
        
    }
}
```

**put方法**
```java
public V put(K key, V value) {
    // 根节点
    Entry<K,V> t = root;
    // 1、空树, 则直接插入
    if (t == null) {
        //若比较器为null则key必须实现Comparable接口，若不为null，key可为null
        compare(key, key); // type (and possibly null) check
        
        // 插入节点
        root = new Entry<>(key, value, null);
        size = 1;
        modCount++;
        return null;
    }
    
    // 2、非空树
    // 记录key排序比较结果
    int cmp;
    // 记录父节点
    Entry<K,V> parent;
    // split comparator and comparable paths
    Comparator<? super K> cpr = comparator;
    // 2.1、若存在比较器，查找节点待插入的位置
    // cmp 小于0往左找，大于0往右找，直至等于0进行替换
    if (cpr != null) {
        do {
            parent = t;
            cmp = cpr.compare(key, t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    // 2.2、不存在比较器
    // key必须实现Comparable接口
    else {
        if (key == null)
            throw new NullPointerException();
        // 使用 key 的比较器查找插入位置
        @SuppressWarnings("unchecked")
        Comparable<? super K> k = (Comparable<? super K>) key;
        do {
            parent = t;
            cmp = k.compareTo(t.key);
            if (cmp < 0)
                t = t.left;
            else if (cmp > 0)
                t = t.right;
            else
                return t.setValue(value);
        } while (t != null);
    }
    
    Entry<K,V> e = new Entry<>(key, value, parent);
    // 插入节点
    if (cmp < 0)
        parent.left = e;
    else
        parent.right = e;
    // 修正红黑树
    fixAfterInsertion(e);
    size++;
    modCount++;
    return null;
}

final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}
// 修正红黑树
private void fixAfterInsertion(Entry<K,V> x) {
    x.color = RED;

    while (x != null && x != root && x.parent.color == RED) {
        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
            Entry<K,V> y = rightOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == rightOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateLeft(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateRight(parentOf(parentOf(x)));
            }
        } else {
            Entry<K,V> y = leftOf(parentOf(parentOf(x)));
            if (colorOf(y) == RED) {
                setColor(parentOf(x), BLACK);
                setColor(y, BLACK);
                setColor(parentOf(parentOf(x)), RED);
                x = parentOf(parentOf(x));
            } else {
                if (x == leftOf(parentOf(x))) {
                    x = parentOf(x);
                    rotateRight(x);
                }
                setColor(parentOf(x), BLACK);
                setColor(parentOf(parentOf(x)), RED);
                rotateLeft(parentOf(parentOf(x)));
            }
        }
    }
    root.color = BLACK;
}
```

**get方法**
```java
public V get(Object key) {
    Entry<K,V> p = getEntry(key);
    return (p==null ? null : p.value);
}

final Entry<K,V> getEntry(Object key) {
    // Offload comparator-based version for sake of performance
    // 1、比较器存在情况
    if (comparator != null)
        return getEntryUsingComparator(key);
    // 2、比较器不存在
    // 要求 key 实现 Comparable接口，null不能抛异常 
    if (key == null)
        throw new NullPointerException();
    // 取出 key 的比较器
    @SuppressWarnings("unchecked")
    Comparable<? super K> k = (Comparable<? super K>) key;
    // 从根节点开始 依次寻找
    Entry<K,V> p = root;
    while (p != null) {
        int cmp = k.compareTo(p.key);
        if (cmp < 0)
            p = p.left;
        else if (cmp > 0)
            p = p.right;
        else
            return p;
    }
    return null;
}

// 比较器查找
// 和使用 key 的比较器查找一样
final Entry<K,V> getEntryUsingComparator(Object key) {
    @SuppressWarnings("unchecked")
    K k = (K) key;
    Comparator<? super K> cpr = comparator;
    if (cpr != null) {
        Entry<K,V> p = root;
        while (p != null) {
            int cmp = cpr.compare(k, p.key);
            if (cmp < 0)
                p = p.left;
            else if (cmp > 0)
                p = p.right;
            else
                return p;
        }
    }
    return null;
}
```

**containsValue方法**
https://juejin.im/post/5acc277551882548fe4a7180

采用中序遍历(LDR左根右)方式来遍历整个红黑树找到相应value
二叉排序树的中序遍历是严格的单调遍历。
```java
public boolean containsValue(Object value) {
    // 中序遍历 所有 Entry
    for (Entry<K,V> e = getFirstEntry(); e != null; e = successor(e))
        // 对比值
        if (valEquals(value, e.value))
            return true;
    return false;
}

// 返回TreeMap中的第一个Entry
final Entry<K,V> getFirstEntry() {
    // 从根节点开始
    Entry<K,V> p = root;
    if (p != null)
        // 一直向左 找到最左边的左孩子
        while (p.left != null)
            p = p.left;
    return p;
}

// 返回指定Entry的后继节点；如果没有，则返回null
static <K,V> TreeMap.Entry<K,V> successor(Entry<K,V> t) {
    // 1、若节点为空没有后继 
    if (t == null)
        return null;
    // 2、如果有 右孩子
    else if (t.right != null) {
        // 向右移动一下
        // 找到右孩子的 最左边的左孩子
        Entry<K,V> p = t.right;
        while (p.left != null)
            p = p.left;
        return p;
    } 
    // 3、没有右孩子 则回退到双亲
    else {
        Entry<K,V> p = t.parent;
        Entry<K,V> ch = t;
        // 存在双亲 且 双亲的右孩子已经遍历过了
        while (p != null && ch == p.right) {
            ch = p;
            p = p.parent;
        }
        return p;
    }
}
```

successor方法找节点的后继节点:
1. 若节点为空没有后继 
2. 若节点有右子树，后继为右子树的最左节点
3. 若节点没有右子树，后继为该节点所在左子树的第一个祖先节点

第 2 种：若节点有右子树，后继为右子树的最左节点  p -> s
![image-20200403194459803](/images/image-20200403194459803.png) 

第 3 种：若节点没有右子树，后继为该节点所在左子树的第一个祖先节点  p -> s
​    1、若其父节点为空，说明 p 是根节点，没有右子树，遍历完成，返回null;
​    2、若其有父节点 且 p 为父节点左子树，返回其父节点;  P -> A
![image-20200403195027806](/images/image-20200403195027806.png)

若其有父节点且 p 为父节点右子树，其所在左子树的第一个祖先节点 p -> s
![image-20200403195211157](/images/image-20200403195211157.png) 

**remove方法**
```java
public V remove(Object key) {
    // 寻找要删除的节点
    Entry<K,V> p = getEntry(key);
    if (p == null)
        return null;

    V oldValue = p.value;
    deleteEntry(p);
    return oldValue;
}

// 删除节点, 并平衡红黑树
private void deleteEntry(Entry<K,V> p) {
    modCount++;
    size--;

    // If strictly internal, copy successor's element to p and then make p
    // point to successor.
    // 1、如果要删除的节点 存在左右子树
    if (p.left != null && p.right != null) {
        // s 是 p 的中序遍历后继节点
        Entry<K,V> s = successor(p);
        // 将 s 的 拷贝给 p，即 s 代替 p
        p.key = s.key;
        p.value = s.value;
        // p 指向 s
        p = s;
        
        // 上述操作后：情况变成了要删除 s
        // 为什么这样？
        // 因为二叉排序树的中序遍历是严格的单调遍历
        // 所以删除 p 的话, s 一定会代替 p 的位置
        
        // 因为 p 有右孩子, 后继为右子树的最左节点, 所以 s 一定没有左孩子
        
    } // p has 2 children

    // Start fixup at replacement node, if it exists.
    // 取 p 的孩子
    Entry<K,V> replacement = (p.left != null ? p.left : p.right);
    // 2、p 有孩子
    if (replacement != null) {
        // Link replacement to parent
        // p 孩子的双亲 改为 p 的双亲
        replacement.parent = p.parent;
        // p 是根节点
        if (p.parent == null)
            root = replacement;
        // 看看放左节点还是右节点
        else if (p == p.parent.left)
            p.parent.left  = replacement;
        else
            p.parent.right = replacement;

        // Null out links so they are OK to use by fixAfterDeletion.
        p.left = p.right = p.parent = null;

        // Fix replacement
        if (p.color == BLACK)
            fixAfterDeletion(replacement);
    } 
    // 3、p 没有孩子, 没有双亲
    // 说明 p 是 根节点
    else if (p.parent == null) { // return if we are the only node.
        root = null;
    } 
    // 3、p 没有孩子, 不是根节点
    else { //  No children. Use self as phantom replacement and unlink.
        // p 是黑色
        if (p.color == BLACK)
            // 删除并修正
            fixAfterDeletion(p);
        
        // 删除 p
        // 把 p 的双亲的引用置空
        if (p.parent != null) {
            if (p == p.parent.left)
                p.parent.left = null;
            else if (p == p.parent.right)
                p.parent.right = null;
            p.parent = null;
        }
    }
}
```
1. p 有两个孩子：
   先找到后继 s，找到后，替换当前节点的内容为后继节点，然后再删除后继节点，因为这个后继节点一定没有左孩子，所以就将两个孩子的情况转换为了后面两种情况
2. p 有一个孩子：用孩子替代自己
3. p 没有孩子：直接将 p 的父节点对应自己的指针置空


## 17.4. 集合遍历方式
1. Iterator：迭代输出，是使用最多的输出方式。
2. ListIterator：是Iterator的子接口，专门用于输出List中的内容。
3. foreach输出：JDK1.5之后提供的新功能，可以输出数组或集合。
4. for循环

遍历 ArrayList
```java
public static void main(String[] args) {
    List<String> list=new ArrayList<String>();
    list.add("Hello");
    list.add("World");
    list.add("HAHAHAHA");

    // 第一种遍历方法使用 For-Each 遍历 List
    // 也可以改写 for(int i=0;i<list.size();i++) 这种形式
    for (String str : list) {
        System.out.println(str);
    }

    // 第二种遍历，把链表变为数组相关的内容进行遍历
    String[] strArray = list.toArray(new String[0]);
    //这里也可以改写为 for(String str:strArray) 这种形式
    for(int i=0; i < strArray.length; i++) {
        System.out.println(strArray[i]);
    }

    // 第三种遍历 使用迭代器进行相关遍历
    Iterator<String> ite = list.iterator();
    // 判断下一个元素之后有值
    while(ite.hasNext())
    {
        System.out.println(ite.next());
    }
}
```

遍历 HashMap
```java
public static void main(String[] args) {
    Map<String, String> map = new HashMap<String, String>();
    map.put("1", "value1");
    map.put("2", "value2");
    map.put("3", "value3");

    //第一种：遍历 key，使用 key 二次取值
    System.out.println("通过Map.keySet遍历key和value：");
    for (String key : map.keySet()) {
        System.out.println("key= "+ key + " and value= " + map.get(key));
    }

    //第二种：使用 entrySet 的迭代器
    System.out.println("通过Map.entrySet使用iterator遍历key和value：");
    Iterator<Map.Entry<String, String>> it = map.entrySet().iterator();
    while (it.hasNext()) {
        Map.Entry<String, String> entry = it.next();
        System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
    }

    //第三种：遍历 entrySet。推荐，尤其是容量大时
    System.out.println("通过Map.entrySet遍历key和value");
    for (Map.Entry<String, String> entry : map.entrySet()) {
        System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
    }

    //第四种：遍历所有 value
    System.out.println("通过Map.values()遍历所有的value，但不能遍历key");
    for (String v : map.values()) {
        System.out.println("value= " + v);
    }
}
```

## 17.5. 快速失败 (fail-fast) 和安全失败 (fail-safe)
快速失败（fail-fast）：
当多个线程对 Collection 进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException 并发修改异常。
原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
```java
final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}
```
注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出（ABA问题）。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

安全失败（fail—safe）:
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

- java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。
- 快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。

**ArrayList和CopyOnWriteArrayList的区别**
1. 和ArrayList继承于AbstractList不同，CopyOnWriteArrayList没有继承于AbstractList，它仅仅只是实现了List接口。
2. ArrayList的iterator()函数返回的Iterator是在AbstractList中实现的；而CopyOnWriteArrayList是自己实现Iterator。
3. ArrayList的Iterator实现类中调用next()时，会“调用checkForComodification()比较‘expectedModCount’和‘modCount’的大小”；但是，CopyOnWriteArrayList的Iterator实现类中，没有所谓的checkForComodification()，更不会抛出ConcurrentModificationException异常！


# 18. IO
Java 的 I/O 大概可以分成以下几类：
- 磁盘操作：File
- 字节操作：InputStream 和 OutputStream
- 字符操作：Reader 和 Writer
- 对象操作：Serializable
- 网络操作：Socket
- 新的输入/输出：NIO

![](/images/IO.png)


## 18.1. File (磁盘文件操作)
File 用于表示文件和目录的信息，但是它不表示文件的内容
```java
/**
 * 递归列出 dir 目录下所有文件
 */
public static void listAllFiles(File dir) {
    if (dir == null || !dir.exists()) {
        return;
    }
    if (dir.isFile()) {
        System.out.println(dir.getName());
        return;
    }
    for (File file : dir.listFiles()) {
        listAllFiles(file);
    }
}
```

## 18.2. 字节流：InputStream 和 OutputStream （输入输出流）
```java
InputStream f = new FileInputStream("C:/java/hello");
OutputStream f = new FileOutputStream("C:/java/hello")

/**
从这个输入流中读取最多len字节的数据到字节数组中。
如果len不为零，这个方法就会阻塞直到有输入可用; 否则，将不读取字节并返回0。

参数:
b – 读取数据的缓冲区。
off -目标数组 b 中的起始偏移量
len -读取的最大字节数。

返回:
读入缓冲区的总字节数，如果已经到达文件的末尾而没有更多数据，则为-1。

抛出:
NullPointerException - 如果b为空。
IndexOutOfBoundsException - 如果off为负数，len为负数，或者len大于b.length
IOException - 如果I/O错误发生。
*/
public int read(byte b[], int off, int len) throws IOException {
    return readBytes(b, off, len);
}

/**
将从指定字节数组开始的len字节写入此文件输出流。

参数:
b - 数据。
off - 数据中的起始偏移量。
len - 要写入的字节数。

抛出:
IOException -如果I/O错误发生。
*/
public void write(byte b[], int off, int len) throws IOException {
    writeBytes(b, off, len, append);
}
```
```java
/**
 * 拷贝文件
 */
public static void copyFile(String src, String dist) throws IOException {
    // 文件输入流（读取文件内容到内存中）
    FileInputStream in = new FileInputStream(src);
    // 文件输出流（内存内容写入到文件中）
    FileOutputStream out = new FileOutputStream(dist);

    byte[] buffer = new byte[20 * 1024];
    int cnt;

    // read() 最多读取 buffer.length 个字节
    // 返回的是实际读取的个数
    // 返回 -1 的时候表示读到 eof，即文件尾
    while ((cnt = in.read(buffer, 0, buffer.length)) != -1) {
        out.write(buffer, 0, cnt);
    }

    in.close();
    out.close();
}
```

## 18.3. 字符流：Reader 和 Writer

### 18.3.1. 字符编码

- GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；
- GB2312 编码中，中文字符占 2 个字节，英文字符占 1 个字节；
- UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；
- UTF-16be 编码中，中文字符占 4 个字节，英文字符占 4 个字节。
（be：大端；le：小端）

> https://www.qqxiuzi.cn/bianma/Unicode-UTF.php
> 
> Unicode 是容纳世界所有文字符号的国际标准编码，使用四个字节为每个字符编码。
> 
> UTF 是英文 Unicode Transformation Format 的缩写，意为把 Unicode 字符转换为某种格式。UTF 系列编码方案（UTF-8、UTF-16、UTF-32）均是由 Unicode 编码方案衍变而来，以适应不同的数据存储或传递，它们都可以完全表示 Unicode 标准中的所有字符。目前，这些衍变方案中 UTF-8 被广泛使用，而 UTF-16 和 UTF-32 则很少被使用。
> 
> UTF-8 使用一至四个字节为每个字符编码，其中大部分汉字采用三个字节编码，少量不常用汉字采用四个字节编码。因为 UTF-8 是可变长度的编码方式，相对于 Unicode 编码可以减少存储占用的空间，所以被广泛使用。
> 
> UTF-16 使用二或四个字节为每个字符编码，其中大部分汉字采用两个字节编码，少量不常用汉字采用四个字节编码。UTF-16 编码有大尾序和小尾序之别，即 UTF-16BE 和 UTF-16LE，在编码前会放置一个 U+FEFF 或 U+FFFE（UTF-16BE 以 FEFF 代表，UTF-16LE 以 FFFE 代表），其中 U+FEFF 字符在 Unicode 中代表的意义是 ZERO WIDTH NO-BREAK SPACE，顾名思义，它是个没有宽度也没有断字的空白。
> 
> UTF-32 使用四个字节为每个字符编码，使得 UTF-32 占用空间通常会是其它编码的二到四倍。UTF-32 与 UTF-16 一样有大尾序和小尾序之别，编码前会放置 U+0000FEFF 或 U+FFFE0000 以区分。

```java
public class Unicode {
    public static void main(String[] args) throws UnsupportedEncodingException {
        chartest("A", "UTF8");
        chartest("a", "UTF16");
        chartest("A", "GBK");
        chartest("A", "GB2312");

        chartest("中", "UTF8");
        chartest("中", "UTF16");
        chartest("中", "GBK");
        chartest("中", "GB2312");
    }
    static void chartest(String str1, String coding) throws UnsupportedEncodingException {
        byte[] bytes = str1.getBytes(coding);
        String str2 = new String(bytes, coding);
        System.out.println(coding + " " + str2 + " " + bytes.length);
        System.out.println("umicode: " + str2.charAt(0) + " "+ Integer.toHexString((int)str2.charAt(0)) );
        System.out.println(Arrays.toString(bytes));
        System.out.println("----");
    }
}
// UTF8 A 1
// umicode: A 41
// [65]
// ----
// UTF16 a 4
// umicode: a 61
// [-2, -1, 0, 97]
// ----
// GBK A 1
// umicode: A 41
// [65]
// ----
// GB2312 A 1
// umicode: A 41
// [65]
// ----
// UTF8 中 3
// umicode: 中 4e2d
// [-28, -72, -83]
// ----
// UTF16 中 4
// umicode: 中 4e2d
// [-2, -1, 78, 45]
// ----
// GBK 中 2
// umicode: 中 4e2d
// [-42, -48]
// ----
// GB2312 中 2
// umicode: 中 4e2d
// [-42, -48]
// ----
```

### 18.3.2. BufferRead 和 BufferWriter

```
Read
  |-- BufferRead
  |-- InputStreamReader 实现从字节流解码成字符流；
        | -- FileReader
```

## 18.4. 序列化

**序列化**是把对象改成可以存到磁盘或通过网络发送到其他运行中的 Java 虚拟机的二进制格式的过程, 并可以通过反序列化恢复对象状态。需要实现 `java.io.Serializable` 接口。**序列化保存的时对象的状态，瞬态和静态变量会不会得到序列化**

序列化一个对象需调用 `ObjectOutputStream.writeObject(saveThisObject)`, 并用 `ObjectInputStream.readObject()` 读取对象

序列化可以看作是深拷贝的一种实现。

### 18.4.1. 序列化相关问题

【1、Java 中的可序列化接口和可外部接口之间的区别是什么？】
Externalizable 给我们提供 writeExternal() 和 readExternal() 方法, 这让我们灵活地控制 Java 序列化机制, 而不是依赖于 Java 的默认序列化。 正确实现 Externalizable 接口可以显著提高应用程序的性能。

【2、可序列化的方法有多少？如果没有方法,那么可序列化接口的用途是什么？】
它没有任何方法, 在 Java 中也称为标记接口。当类实现 `java.io.Serializable` 接口时, 它将在 Java 中变得可序列化, 并指示编译器使用 Java 序列化机制序列化此对象。

【3、如果可序列化类中的一个成员未实现可序列化接口，会发生什么情况？】
在运行时将引发不可序列化异常 `NotSerializableException`。可以将其设置瞬态(**transient**)变量。

【4、如果类是可序列化的, 但其超类不是, 则反序列化后从超级类继承的实例变量的状态如何？】
超级类继承的实例变量的值将通过调用构造函数初始化。且一旦**构造函数链**启动, 就不可能停止，因此即使层次结构中更高的类成员变量实现了可序列化接口， 也将通过执行构造函数创建，而不再是反序列化得到。

【5、是否可以自定义序列化过程, 或者是否可以覆盖 Java 中的默认序列化过程？】
对于序列化一个对象需调用 `ObjectOutputStream.writeObject(saveThisObject)`, 并用 `ObjectInputStream.readObject()` 读取对象。
如果在类中定义这两种方法, 则 JVM 将调用这两种方法, 而不是应用默认序列化机制。
需要注意的重要一点是要声明这些方法为私有方法, 以避免被继承、重写或重载。 由于只有 Java 虚拟机可以调用类的私有方法, 你的类的完整性会得到保留, 并且 Java 序列化将正常工作。

【6、假设新类的超级类实现可序列化接口, 如何避免新类被序列化？】
为了避免 Java 序列化,你需要在类中实现 `writeObject()` 和 `readObject()` 方法, 并且需要从该方法引发不序列化异常`NotSerializableException`。 
这是自定义 Java 序列化过程的另一个好处。

【7、在 Java 序列化期间,哪些变量未序列化？】
**瞬态和静态变量会不会得到序列化**
由于静态变量属于类, 而不是对象, 因此它们不是对象状态的一部分；
由于序列化仅保留**对象的状态**而不是对象本身，瞬态变量也不包含在 Java 序列化过程中。


## 18.5. NIO

Non-blocking I/O 是一种同步非阻塞的I/O模型，也是I/O多路复用的基础，已经被越来越多地应用到大型应用服务器，成为解决高并发与大量连接、I/O处理问题的有效方式。

https://zhuanlan.zhihu.com/p/23488863


# 19. JDBC

步骤 0: 导入 mysql-jdbc 的驱动 jar 包
步骤 1: 初始化驱动
步骤 2: 建立与数据库的连接
步骤 3: 创建Statement
步骤 4: 执行SQL语句
步骤 5: 遍历结果集
步骤 6: 关闭连接
```java
public class JDBCDemo {
    public static void main(String[] args) throws Exception{
        // 1.注册驱动
        // DriverManager.registerDriver(new com.mysql.jdbc.Driver());
        Class.forName("com.mysql.jdbc.Driver");

        // 2.获取连接
        Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/eesy","root","1234");
        // 3.获取操作数据库的预处理对象
        PreparedStatement pstm = conn.prepareStatement("select * from account");
        // 4.执行SQL，得到结果集
        ResultSet rs = pstm.executeQuery();
        // 5.遍历结果集
        while(rs.next()){
            System.out.println(rs.getString("name"));
        }
        // 6.释放资源
        rs.close();
        pstm.close();
        conn.close();
    }
}
```


# 20. 网络编程

通讯协议（应用层）：以字符 '#' 结束一次数据交互；以字符串 "bye" 结束会话。

服务端
```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.ServerSocket;
import java.net.Socket;

public class MyChatRoomServer {
    public static void main(String[] args)
    {
        MyChatRoomServer server = new MyChatRoomServer();
        server.runServer(1762);
    }

    /*
     * 创建服务器，等待客户机的连接并进行通信
     * 参数：port 端口号
     */
    public void runServer(int port) {
        try
        {
            // 创建一个服务器对象
            ServerSocket ss = new ServerSocket(port);
            System.out.println("服务器创建成功，端口号：" + ss.getLocalPort() + "等待连接中...");

            // 等待客户机连接
            // 侦听并接受到此套接字的连接。此方法在连接传入之前一直阻塞。
            Socket client = ss.accept();
            System.out.println("连接成功，连接的客户机是：" + client.getPort());

            // 获得Socket对象的输入输出流
            OutputStream out = client.getOutputStream();
            InputStream ins = client.getInputStream();

            String s = "你好,欢迎来到Song的聊天室\r\n";
            // 取得组成这个字符串的字节
            byte[] data = s.getBytes();
            out.write(data); // 用输出对象发送！
            out.flush(); // 强制缓冲区输出

            String msg;
            for(;!"bye".equals(msg = readString(ins));)
            {
                System.out.println(client.getPort()+": "+msg);
            }
            System.out.println(client.getPort()+": "+msg);

            // 关闭与客户机的连接
            client.close();
        }
        catch (IOException e)
        {
            e.printStackTrace();
        }
    }

    /*
     * 读取一个以'\r'结尾字符串输入
     */
    private String readString(InputStream ins) throws IOException
    {
        StringBuffer msg = new StringBuffer();// 创建一个字符串缓冲区
        int a = 0;
        char c = 0;
        for(;(a = ins.read()) != '#';)// 读取客户机的一个字节，以'#'结束
        {
            c = (char)a;// 将输入流转换为字符显示
            msg.append(c);// 将读到的字符加到字符缓冲区中
        }
        String s = msg.toString().trim();// 将读到的BufferString转换为字符串，并调用trim()去掉尾部的空格
        return s;// 返回得到的字符串
    }
}
```

客户端
```java
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.net.Socket;
import java.util.Scanner;

public class MyChatRoomClient {
    public static void main(String[] args) {
        MyChatRoomClient client = new MyChatRoomClient();
        client.runClient("localhost", 1762);
    }

    /*
     * 创建客户端
     * 参数：ip 目标服务器 ip;port 端口号
     */
    public void runClient(String ip, int port) {
        try
        {
            Socket clientSocket =  new Socket("localhost", port); ;
            DataInputStream in = new DataInputStream(clientSocket.getInputStream());;
            DataOutputStream out = new DataOutputStream(clientSocket.getOutputStream());;
            Scanner sc = new Scanner(System.in);
            String s;

            while (!(s = sc.nextLine()).equals("bye")) {
                System.out.println("发送 ["+s+"] 成功");
                out.writeUTF(s+"#");
            }
            System.out.println("发送 ["+s+"] 成功");
            out.writeUTF(s+"#");

            sc.close();
            out.close();
            in.close();
            clientSocket.close();
        }
        catch(Exception ee)
        {

        }
    }
}
```

```
# MyChatRoomServer
服务器创建成功，端口号：1762等待连接中...
连接成功，连接的客户机是：13063
13063: hello
13063: hahaha
13063: bye

# MyChatRoomClient
hello
发送 [hello] 成功
hahaha
发送 [hahaha] 成功
bye
发送 [bye] 成功
```

# 21. JNI

1、创建一个包 `mkdir -p priv/abadstring/jni/`
2、创建一个java文件 `vi priv/abadstring/jni/JNIDemo.java`
```java
package priv.abadstring.jni;

public class JNIDemo {
    public native void sayHelloByC();

    public static void main(String[] args) {
        // 打印一下当前 VM 中库目录
        System.out.println( System.getProperty("java.library.path"));
        // 加载动态库
        System.loadLibrary("JNIDemoByC");
        new JNIDemo().sayHelloByC();
    }
}
```

3、编译`javac priv/abadstring/jni/JNIDemo.java`

4、生成头文件`javah -classpath . -jni priv.abadstring.jni.JNIDemo`
```c++
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class priv_abadstring_jni_JNIDemo */

#ifndef _Included_priv_abadstring_jni_JNIDemo
#define _Included_priv_abadstring_jni_JNIDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     priv_abadstring_jni_JNIDemo
 * Method:    sayHelloByC
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_priv_abadstring_jni_JNIDemo_sayHelloByC
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

将生成的头文件放到包下 `mv priv_abadstring_jni_JNIDemo.h priv/abadstring/jni/`

目前文件结构
```
.
└── priv
    └── abadstring
        └── jni
            ├── JNIDemo.class
            ├── JNIDemo.java
            └── priv_abadstring_jni_JNIDemo.h
```

5、新建一个C++源文件 `vi priv/abadstring/jni/JNIDemoByC.c`
内容就是头文件的实现函数
```C
#include "priv_abadstring_jni_JNIDemo.h"
#include <stdio.h>

JNIEXPORT void JNICALL Java_priv_abadstring_jni_JNIDemo_sayHelloByC(JNIEnv * env, jobject obj)
{
    printf("hello, jni. I am C.");
}
```

6、查找一下jdk的安装位置 `sudo tree /usr/lib/jvm/java-8-openjdk-amd64/include/`
```
/usr/lib/jvm/java-8-openjdk-amd64/include/
├── classfile_constants.h
├── jdwpTransport.h
├── jni.h
├── jvmticmlr.h
├── jvmti.h
└── linux
    └── jni_md.h
```

发现 jni.h 和 jni_md.h 的位置，这个一会编译动态库时需要

6、创建动态库 
```shell
gcc -shared -fPIC -o priv/abadstring/jni/libJNIDemoByC.so priv/abadstring/jni/JNIDemoByC.c -I/usr/lib/jvm/java-8-openjdk-amd64/include -I/usr/lib/jvm/java-8-openjdk-amd64/include/linux
```
动态库的名字格式是`libxxx.so`
xxx必须和 Java 源代码中载入的名字 JNIDemoByC 相同。

动态库生成成功
```
.
└── priv
    └── abadstring
        └── jni
            ├── JNIDemoByC.c
            ├── JNIDemo.class
            ├── JNIDemo.java
            ├── libJNIDemoByC.so
            └── priv_abadstring_jni_JNIDemo.h
```

7、运行起来
```shell
java -Djava.library.path="./priv/abadstring/jni" priv.abadstring.jni.JNIDemo
```
结果：
```
./priv/abadstring/jni
hello, jni. I am C.
```

-D 必须在类前面，这种不行 `java priv.abadstring.jni.JNIDemo -Djava.library.path="./priv/abadstring/jni"`


# 22. Java Web 三大组件

- Servlet 用到了模板方法模式：HttpServlet 是一个抽象类，需要子类继承并重写 doGet doPost 等方法。
- Filter 用到了责任链模式：在一个 URL 上可以有多个 Filter，执行完一个 Filter 之后。通过 FilterChain 的 doFilter 方法继续往后执行下一个 Filter，直到执行到 Servlet。
- Listener 用到了观察者模式：当 Request 等对象更新了之后会调用 ServletRequestListener 相应的方法。

## 22.1. Servlet

创建servlet有三种方式:
- 实现Servlet接口
- 继承GenericServlet类
- 继承HttpServlet类

```java
package javax.servlet;
import java.io.IOException;
public interface Servlet {
    void init(ServletConfig var1) throws ServletException;
    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
    void destroy();
    ServletConfig getServletConfig();
    String getServletInfo();
}

public interface ServletConfig {
    String getServletName();
    ServletContext getServletContext();
    String getInitParameter(String var1);
    Enumeration<String> getInitParameterNames();
}
```

Servlet 的生命周期：
1. Servlet 通过调用 init () 方法进行初始化。
2. Servlet 调用 service() 方法来处理客户端的请求。
3. Servlet 通过调用 destroy() 方法终止（结束）。
4. 最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。

Servlet 的一个实现类 HttpServlet
```java
package javax.servlet;
public abstract class GenericServlet implements Servlet, ServletConfig, Serializable {
    public abstract void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;
}

package javax.servlet.http;
public abstract class HttpServlet extends GenericServlet {
    public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException {
        if (req instanceof HttpServletRequest && res instanceof HttpServletResponse) {
            HttpServletRequest request = (HttpServletRequest)req;
            HttpServletResponse response = (HttpServletResponse)res;
            this.service(request, response);
        } else {
            throw new ServletException("non-HTTP request or response");
        }
    }
    // 在 service 方法中，根据不同的请求类型
    // 调用不同的 doGet doPost 等方法
    protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String method = req.getMethod();
        long lastModified;
        if (method.equals("GET")) {
            lastModified = this.getLastModified(req);
            if (lastModified == -1L) {
                this.doGet(req, resp);
            } else {
                long ifModifiedSince = req.getDateHeader("If-Modified-Since");
                if (ifModifiedSince < lastModified) {
                    this.maybeSetLastModified(resp, lastModified);
                    this.doGet(req, resp);
                } else {
                    resp.setStatus(304);
                }
            }
        } else if (method.equals("HEAD")) {
            lastModified = this.getLastModified(req);
            this.maybeSetLastModified(resp, lastModified);
            this.doHead(req, resp);
        } else if (method.equals("POST")) {
            this.doPost(req, resp);
        } else if (method.equals("PUT")) {
            this.doPut(req, resp);
        } else if (method.equals("DELETE")) {
            this.doDelete(req, resp);
        } else if (method.equals("OPTIONS")) {
            this.doOptions(req, resp);
        } else if (method.equals("TRACE")) {
            this.doTrace(req, resp);
        } else {
            String errMsg = lStrings.getString("http.method_not_implemented");
            Object[] errArgs = new Object[]{method};
            errMsg = MessageFormat.format(errMsg, errArgs);
            resp.sendError(501, errMsg);
        }
    }
}
```

**1、servlet是不是单例设计模式?**
Servlet 并不是单例设计模式,如果有多个Url映射到同一个 Servlet 时,就会出现多个实例。虽然 Servlet 在多数情况下只有一个实例。但它并不是单例设计模式，即不是真正的单例。

**2、serlvet线程安全问题?**
基于 JVM 对多线程的支持，这样可以提高代码的执行效率。 不需要为每一个请求都要单独创建/销毁 Servlet（执行 init(), desdroy()）。同一段代码可以在同一时间被多个请求同时执行。 Servlet 是普通的 Java 类，因此没有对其做线程安全的处理

## 22.2. Filter

```java
package javax.servlet;
import java.io.IOException;
public interface Filter {
    void init(FilterConfig var1) throws ServletException;
    void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException;
    void destroy();
}

package javax.servlet;
import java.io.IOException;
public interface FilterChain {
    void doFilter(ServletRequest var1, ServletResponse var2) throws IOException, ServletException;
}

```

Filter 接口中有一个 doFilter 方法，当我们编写好 Filter 需要实现这个方法，并在web.xml中配置。
当每次请求对应的url之前，都会先调用一下filter的doFilter方法。

doFilter 第三个参数是 FilterChain 类型的

### 22.2.1. Filter的四种拦截方式
- REQUEST：直接访问目标资源时执行过滤器。包括：在地址栏中直接访问、表单提交、超链接、重定向，只要在地址栏中可以看到目标资源的路径，就是REQUEST；
- FORWARD：转发访问执行过滤器。包括RequestDispatcher#forward()方法、<jsp:forward>标签都是转发访问；
- INCLUDE：包含访问执行过滤器。包括RequestDispatcher#include()方法、<jsp:include>标签都是包含访问；
- ERROR：当目标资源在web.xml中配置为<error-page>中时，出现异常后，转发到目标资源时，会执行过滤器。


## 22.3. Listener

```java
package javax.servlet.http;
import java.util.EventListener;
public interface HttpSessionListener extends EventListener {
    void sessionCreated(HttpSessionEvent var1);
    void sessionDestroyed(HttpSessionEvent var1);
}

package javax.servlet;
import java.util.EventListener;
public interface ServletRequestListener extends EventListener {
    void requestDestroyed(ServletRequestEvent var1);
    void requestInitialized(ServletRequestEvent var1);
}
```


# 23. Java 常用类

## 23.1. Object 类

Object类是所有Java类的根父类。

如果一个类没有显示地继承某个类，那么这个类会默认继承Object类。

Object类有一个空参构造器。

Object类中有12个方法，
其中 1 个 private，2 个protected，9 个 public；6 个 final 方法；7 个 native 方法；有三个重载方法wait方法。
finalize 方法由 GC 在清理对象前调用一次，可以看作析构函数。

```java
public class Object {

    private static native void registerNatives();
    static {
        registerNatives();
    }

    public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
    public final native Class<?> getClass();

    public boolean equals(Object obj) {
        return (this == obj);
    }
    public native int hashCode();
    
    public final native void notify();
    public final native void notifyAll();
    public final void wait() throws InterruptedException {
        wait(0);
    }
    public final void wait(long timeout, int nanos) throws InterruptedException {
        if (timeout < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (nanos < 0 || nanos > 999999) {
            throw new IllegalArgumentException(
                "nanosecond timeout value out of range");
        }

        if (nanos > 0) {
            timeout++;
        }

        wait(timeout);
    }
    public final native void wait(long timeout) throws InterruptedException;

    protected void finalize() throws Throwable {
    }
    
    protected native Object clone() throws CloneNotSupportedException;
}
```

### 23.1.1. equals方法

**equals()方法需要具有如下特点：**

　　**自反性（reflexive）：**任何非空引用x，x.equals(x)返回为true。

　　**对称性（symmetric）：**任何非空引用x和y，x.equals(y)返回true当且仅当y.equals(x)返回true。

　　**传递性（transitive）：**任何非空引用x和y，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true。

　　**一致性（consistent）：**两个非空引用x和y，x.equals(y)的多次调用应该保持一致的结果，（前提条件是在多次比较之间没有修改x和y用于比较的相关信息）。

　　**约定**：对于任何非空引用x，x.equals(null)应该返回为false。

　　并且覆写equals()方法时，应该同时覆写hashCode()方法，反之亦然。



【面试题】== 与equals的区别。
​    答：
​        == : 如果比较的是基本数据类型，那么比较的是变量的值（存在自动类型提升）。如果比较的是引用数据类型，那么比较的也是变量的值（地址值），即比较两个引用是否指向同一个对象。
​        equals : 是一个方法，可以被重写。在Object类中等同于==。像String、Date等类都重写了equls方法，用来比较内容。



Object类的equals方法比较两个引用所指向的是不是同一个对象。

String类重写了该方法：比较字符串的内容是否相同。

```java
public boolean equals(Object anObject) {
    if (this == anObject) {
        return true;
    }
    if (anObject instanceof String) {
        String anotherString = (String)anObject;
        int n = value.length;
        if (n == anotherString.value.length) {
            char v1[] = value;
            char v2[] = anotherString.value;
            int i = 0;
            while (n-- != 0) {
                if (v1[i] != v2[i])
                    return false;
                i++;
            }
            return true;
        }
    }
    return false;
}
```

### 23.1.2. hashCode方法

这个方法返回一个整型值（hash code value），如果两个对象被equals()方法判断为相等，那么它们就应该拥有同样的 hash code。

Object类的hashCode()方法为不同的对象返回不同的值，Object类的hashCode值表示的是对象的地址。

### 23.1.3. toString方法

输出一个引用时，实际上是先默认调用了toString方法得到一个字符串，然后调用重载方法public void System.out.println(String x)。

![image-20200403141045044](/images/image-20200403141045044.png) 

### 23.1.4. clone方法

1、想要重写clone方法的类必须实现 java.lang.Cloneable 接口，否则会抛出CloneNotSupportedException异常。Cloneable接口中不包含任何方法，所以实现它时只要在类声明中加上implements语句即可。

```java
public interface Cloneable {
}
```

2、这个方法是protected修饰的，覆写clone()方法的时候需要写成public，才能让类外部的代码调用。

- p1 = p  引用赋值，两个引用指向同一对象。

![image-20200403144313786](/images/image-20200403144313786.png) 

- p1 = (Person) p.clone()，clone是浅拷贝的

![image-20200403151019992](/images/image-20200403151019992.png) 

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    return super.clone();
}
```

- 深拷贝

![image-20200403151536701](/images/image-20200403151536701.png) 

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    User user = (User)super.clone();
    user.teacher = (Teacher) this.teacher.clone();
    return user;
}
```

- 不彻底的深拷贝

![image-20200403151718701](/images/image-20200403151718701.png) 


## 23.2. 包装类(Wrapper)

![](/images/包装类.png)

### 23.2.1. 基本数据类型、包装类、String之间的转换
 
![](/images/基本数据类型和包装类之间的转化.png)

- 基本数据类型 -> 包装类：包装类的构造器，Integer integer = new Integer(a);
- 包装类 -> 基本数据类型：调用包装类的xxxValue()方法，int a = integer.intValue();
- 拆箱和装箱：直接赋值，Integer integer = a; int b = integer;
- String -> 基本数据类型：调用包装类的parseXxx(String)静态方法，int a = Integer.parseInt(str);
- String -> 包装类：包装类的构造器，Integer integer = new Integer(str);
- 基本数据类型 -> String：调用String类的valueOf()静态方法，String str = String.valueOf(10);
- 包装类 -> String：调用包装类的toString()方法，String str = String.valueOf(integer);

### 23.2.2. 拆箱与装箱

拆箱：将包装类直接赋值给基本数据类型。底层是调用了intValue方法。
装箱：将基本数据类型直接赋值给包装类。底层是调用了valueOf方法。
```java
Integer x = 2;     // 装箱 调用了 Integer.valueOf(2)
int y = x;         // 拆箱 调用了 X.intValue()
```

注意String转Boolean时有个坑：只有"true"(忽略大小写)转为true，其余(包括null)转为false。这里是源码：
```java
public Boolean(String s) {
    this(parseBoolean(s));
}
public static boolean parseBoolean(String s) {
    return "true".equalsIgnoreCase(s);
}
```

包装类可以自动拆箱，然后自动类型提升，然后自动装箱。看看这段代码的输出：
```java
@Test
public void test01() {
    Object ob = true ? new Integer(1) : new Double(2.0);
    System.out.println(ob);
    System.out.println(ob.getClass());
}
// 结果：
// 1.0
// class java.lang.Double
```
这个：神奇的结果。
```java
@Test
public void test02() {
    Integer i = new Integer(1);
    Integer j = new Integer(1);
    System.out.println(i == j);
    
    Integer m = 1;
    Integer n = 1;
    System.out.println(m == n);
    
    Integer x = 128;
    Integer y = 128;
    System.out.println(x == y);
}
// 结果：
// false
// ture
// false 
```
原因：Integer m = 1; 的底层是调用了valueOf方法。当i的值在low (-128)到high (127)之间时，是不会创建对象的。在此区间以外，会创建新对象。
```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```
类似的，Short也是：
```java
public static Short valueOf(short s) {
    final int offset = 128;
    int sAsInt = s;
    if (sAsInt >= -128 && sAsInt <= 127) { // must cache
        return ShortCache.cache[sAsInt + offset];
    }
    return new Short(s);
}
```

基本类型对应的缓冲池如下：
- boolean values true and false
- all byte values
- short values between -128 and 127
- int values between -128 and 127
- char in the range \u0000 to \u007F (0 ~ 127)

在 jdk 1.8 所有的数值类缓冲池中，Integer 的缓冲池 IntegerCache 很特殊，这个缓冲池的下界是 - 128，上界默认是 127，但是这个上界是可调的。
在启动 jvm 的时候，通过 `-XX:AutoBoxCacheMax=<size>` 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为`java.lang.IntegerCache.high`系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界。
```java
static {
    // high value may be configured by property
    int h = 127;
    String integerCacheHighPropValue =
        sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
    if (integerCacheHighPropValue != null) {
        try {
            int i = parseInt(integerCacheHighPropValue);
            i = Math.max(i, 127);
            // Maximum array size is Integer.MAX_VALUE
            // 数组最大长度是 Integer.MAX_VALUE
            h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
        } catch( NumberFormatException nfe) {
            // If the property cannot be parsed into an int, ignore it.
        }
    }
    high = h;

    cache = new Integer[(high - low) + 1];
    int j = low;
    for(int k = 0; k < cache.length; k++)
        cache[k] = new Integer(j++);

    // range [-128, 127] must be interned (JLS7 5.1.7)
    assert IntegerCache.high >= 127;
}
```

## 23.3. String类和常量池
1、String类被final所修饰，所有该类不能被继承。
2、实现了Serializable接口可以被序列化，被序列化后才能在不同的进程间或前后端进行数据传输。
3、实现了Compareable接口可以用来比较内容。
4、实现了CharSequence接口可以用来获取字符串长度，可以获取字符串中的某个字符。
5、String对象的创建：String s = new String("aaa"); 。
6、字符串都放在常量池中.
7、String的底层是一个数组：private final char value[]; 该数组被final所修饰，所以**String是一个不可变的字符序列**。修改字符串时不会在原来的字符串对象上修改，而是会创建一个新的字符串。

在 Java 8 中，String 内部使用 char 数组存储数据。
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}
```
在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 coder 来标识使用了哪种编码。
```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}
```
value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。


### 23.3.1. String 的不可变性

当对字符串引用重新赋值或者改变字符串的内容时，会重新创建一个字符串对象，而不会去改变原来对象的内容。

通过字面量的方式给字符串赋值，字符串对象会创建在方法区的常量池当中，栈中的引用直接引用常量池地址，多个相同内容的字符串共用一个常量池中的对象。
如果给字符串重新赋值，那么会重写在常量池中创建一个字符串对象，让栈上的引用重新指向改对象，而不会改变原来的字符串对象。

#### 23.3.1.1. 不可变性的好处

1. 可缓存 hash 值

2. 可以使用 String Pool
在 Java 7 之前，String Pool 被放在运行时常量池中，它属于永久代。而在 Java 7，String Pool 被移到堆中。

3. 安全性
String 经常作为参数，String 不可变性可以保证参数不可变。
例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是。

4. 线程安全
String 不可变性天生具备线程安全，可以在多个线程中安全地使用。


### 23.3.2. String 的几种构造器

```java
// 这种就是引用间赋值，把地址值拷贝给引用变量
// 想想在 C 中，字符串字面量代表的就是字符串的首地址值
String str = "hello";

// this.value = "".value;
String s1 = new String();

// this.value = original.value;
// this.hash = original.hash;
String s2 = new String(String original);

// this.value = Arrays.copyOf(a, a.length)
String s3 = new String(char[] a);

// this.value = Arrays.copyOfRange(a, startIndex, startIndex+count)
String s4 = new String(char[] a, int startIndex, int count);
```
- 方式一：通过字面量定义的方式。直接在常量区创建对象，将引用指向它
- 方式二：通过new + 构造器的方式。在常量区和堆中分别创建对象，引用执行堆上的对象。
```java
@Test
public void test01() {
    String s1 = "aaa";
    String s2 = "aaa";
    String s3 = new String("aaa");
    String s4 = new String("aaa");
    System.out.println(s1 == s2);
    System.out.println(s3 == s4);
}
```
【面试题】String s = new String("aaa");在内存中创建了几个对象？
答：如果"aaa"已经在常量池中创建了，那么创建了1个对象；如果"aaa"没有在常量池中创建过，那么创建了两个对象。堆中一个，常量池中一个。
![](/images/String构造器.png)

猜猜下面代码的运行结果：
```java
@Test
public void test02() {
    String s = "hellojava";
    String s1 = "hello";
    String s2 = "java";
    // 编译时就会将字符串拼接，和s没有区别
    String s3 = "hello" + "java";
    // 只有有变量参与字符串拼接，
    // 那么就会调用StringBuilder中的toString方法
    // 创建一个新的Sting对象。
    String s4 = s1 + "java";
    String s5 = "hello" + s2;
    String s6 = s1 + s2;
    // 直接去内存中的常量池中获取该字符串对象
    String s7 = s6.intern();
    System.out.println(s == s3); // true
    System.out.println(s == s4); // false
    System.out.println(s == s5); // false
    System.out.println(s == s6); // false
    System.out.println(s4 == s5); // false
    System.out.println(s4 == s6); // false
    System.out.println(s == s7); // true
}
```
结论：
    1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量。
    2.只要其中有一个是变量，结果就在堆中。
    3.如果拼接的结果调用intern()方法，返回值就在常量池中

![](/images/字符串的不可变性.png)

另外，final 常量也是编译器处理，
```java
@Test
public void test4(){
    String s1 = "javaEEhadoop";
    String s2 = "javaEE";
    String s3 = s2 + "hadoop";
    System.out.println(s1 == s3);//false

    final String s4 = "javaEE";//s4:常量
    String s5 = s4 + "hadoop";
    System.out.println(s1 == s5);//true
}
```

### 23.3.3. String 常用 API
**基本：**
`int length()`：返回字符串的长度： return value.length
`boolean isEmpty()`：判断是否是空字符串：return value.length == 0
`String toLowerCase()`：使用默认语言环境，将 String 中的所有字符转换为小写
`String toUpperCase()`：使用默认语言环境，将 String 中的所有字符转换为大写
`String trim()`：返回字符串的副本，忽略前导空白和尾部空白
**比较：**
`boolean equals(Object obj)`：比较字符串的内容是否相同
`boolean equalsIgnoreCase(String anotherString)`：与equals方法类似，忽略大小写
`String concat(String str)`：将指定字符串连接到此字符串的结尾。 等价于用“+”
`int compareTo(String anotherString)`：比较两个字符串的大小
**截取子串**
`char charAt(int index)`： 返回某索引处的字符return value[index]
`String substring(int beginIndex)`：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。
`String substring(int beginIndex, int endIndex)`：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。
**获取子串出现的位置：**
`int indexOf(String str)`：返回指定子字符串在此字符串中第一次出现处的索引
`int indexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始
`int lastIndexOf(String str)`：返回指定子字符串在此字符串中最右边出现处的索引
`int lastIndexOf(String str, int fromIndex)`：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索
注：indexOf和lastIndexOf方法如果未找到都是返回-1
**替换：**
`String replace(char oldChar, char newChar)`：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。
`String replace(CharSequence target, CharSequence replacement)`：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串。
`String replaceAll(String regex, String replacement)`：使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。
`String replaceFirst(String regex, String replacement)`：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。
**匹配:**
`boolean contains(CharSequence s)`：当且仅当此字符串包含指定的 char 值序列时，返回 true
`boolean endsWith(String suffix)`：测试此字符串是否以指定的后缀结束
`boolean startsWith(String prefix)`：测试此字符串是否以指定的前缀开始
`boolean startsWith(String prefix, int toffset)`：测试此字符串从指定索引开始的子字符串是否以指定前缀开始
`boolean matches(String regex)`：告知此字符串是否匹配给定的正则表达式。
**切片：**
`String[] split(String regex)`：根据给定正则表达式的匹配拆分此字符串。
`String[] split(String regex, int limit)`：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。

### 23.3.4. String 与其他结构的转换

- **String 与基本数据类型和包装类的转换**
[基本数据类型、包装类、String之间的转换](#921-基本数据类型-包装类-string之间的转换)

String --> 基本数据类型、包装类：调用包装类的静态方法：parseXxx(str)
基本数据类型、包装类 --> String:调用String重载的valueOf(xxx)

- **String 与byte[]的转换**
编码：String --> byte[]: 调用String 的 getBytes()
解码：byte[] --> String: 调用String 的构造器

编码：字符串 --> 字节  (看得懂 ---> 看不懂的二进制数据)
解码：编码的逆过程，字节 --> 字符串 （看不懂的二进制数据 ---> 看得懂）

说明：解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码。

```java
@Test
public void test3() throws UnsupportedEncodingException {
    String str1 = "abc123中国";
    byte[] bytes = str1.getBytes();//使用默认的字符集，进行编码。
    System.out.println(Arrays.toString(bytes));

    byte[] gbks = str1.getBytes("gbk");//使用gbk字符集进行编码。
    System.out.println(Arrays.toString(gbks));

    System.out.println("******************");

    String str2 = new String(bytes);//使用默认的字符集，进行解码。
    System.out.println(str2);

    String str3 = new String(gbks);
    System.out.println(str3);//出现乱码。原因：编码集和解码集不一致！


    String str4 = new String(gbks, "gbk");
    System.out.println(str4);//没有出现乱码。原因：编码集和解码集一致！
}
```

- **String 与char[]的转换**
String --> char[]: 调用 String 的 toCharArray()
char[] --> String: 调用 String 的构造器

```java
@Test
public void test2(){
    String str1 = "abc123";  //题目： a21cb3

    char[] charArray = str1.toCharArray();
    for (int i = 0; i < charArray.length; i++) {
        System.out.println(charArray[i]);
    }

    char[] arr = new char[]{'h','e','l','l','o'};
    String str2 = new String(arr);
    System.out.println(str2);
}
```

### 23.3.5. StringBuffer 和 StringBuilder

- String: 不可变的字符序列；底层使用char[]存储
- StringBuffer: 可变的字符序列；线程安全的，效率低；底层使用char[]存储
- StringBuilder: 可变的字符序列；线程不安全的，效率高；底层使用char[]存储，jdk5.0新增的

String 是不可变的对象。在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，非常耗费性能。
StringBuffer 则是每次都会对 StringBuffer 对象本身进行操作。
三者的效率：StringBuilder > StringBuffer > String

**源码分析**
```java
// String 空参构造器，会创建一个长度为 0 在 char 数组
// char[] value = new char[0];
String str = new String();
// 带参构造器创建相应大小的数组
// char[] value = new char[]{'a','b','c'};
String str1 = new String("abc");

// StringBuffer 空参构造器，创建了一个长度是 16 的数组
// char[] value = new char[16];
StringBuffer sb1 = new StringBuffer();。
System.out.println(sb1.length()); // 0
sb1.append('a'); // value[0] = 'a';
sb1.append('b'); // value[1] = 'b';
System.out.println(sb1.length()); // 2
// 带参构造器创建相应大小 + 16 的数组
// char[] value = new char["abc".length() + 16];
StringBuffer sb2 = new StringBuffer("abc");

// 问题1. System.out.println(sb2.length());//3
// 问题2. 扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
//        默认情况下，扩容为原来容量的2倍 + 2，同时将原有数组中的元素复制到新的数组中。
// 指导意义：开发中建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)
```

**StringBuffer 常用方法**
`StringBuffer append(xxx)`：提供了很多的append()方法，用于进行字符串拼接
`StringBuffer delete(int start, int end)`：删除指定位置的内容
`StringBuffer replace(int start, int end, String str)`：把[start,end)位置替换为str
`StringBuffer insert(int offset, xxx)`：在指定位置插入xxx
`StringBuffer reverse()`：把当前字符序列逆转
`public int indexOf(String str)`：返回指定子字符串在此字符串中第一次出现处的索引
`public String substring(int start,int end)`：返回一个从start开始到end索引结束的左闭右开区间的子字符串
`public int length()`
`public char charAt(int n )`
`public void setCharAt(int n ,char ch)`：修改索引 n 位置处的字符串为 ch
总结：
增：append(xxx)
删：delete(int start,int end)
改：setCharAt(int n ,char ch) / replace(int start, int end, String str)
查：charAt(int n )
插：insert(int offset, xxx)
长度：length();
遍历：for() + charAt() / toString()

**效率对比**
```java
public static void main(String[] args) {
    // 初始设置
    long startTime = 0L;
    long endTime = 0L;
    String text = "";
    StringBuffer buffer = new StringBuffer("");
    StringBuilder builder = new StringBuilder("");

    // 开始对比
    startTime = System.currentTimeMillis();
    for (int i = 0; i < 20000; i++) {
        buffer.append(String.valueOf(i));
    }
    endTime = System.currentTimeMillis();
    System.out.println("StringBuffer的执行时间：" + (endTime - startTime));

    startTime = System.currentTimeMillis();
    for (int i = 0; i < 20000; i++) {
        builder.append(String.valueOf(i));
    }
    endTime = System.currentTimeMillis();
    System.out.println("StringBuilder的执行时间：" + (endTime - startTime));

    startTime = System.currentTimeMillis();
    for (int i = 0; i < 20000; i++) {
        text = text + i;
    }
    endTime = System.currentTimeMillis();
    System.out.println("String的执行时间：" + (endTime - startTime));
}
// StringBuffer的执行时间：9
// StringBuilder的执行时间：4
// String的执行时间：1637
```

## 23.4. 时间有关类

System 类中的时间 API
```java
// 返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差。
// 称为时间戳
long time = System.currentTimeMillis();
```

### 23.4.1. java.util.Date
java.util.Date 有多个重载的构造器，但许多都过时啦，这里介绍两个
1. Date()：创建一个对应当前时间的Date对象
2. Date(long date)：创建指定毫秒数的Date对象

toString()：显示当前Date对象 星期 月 日 时:分:秒 标准时间+时差 年。`Mon Aug 10 19:54:10 GMT+08:00 2020`
getTime()：获取当前Date对象对应的毫秒数（时间戳）。

### 23.4.2. java.sql.Date
```java
public class java.sql.Date extends java.util.Date
```
继承自 java.util.Date，对应数据库中的 date 类型。
只有一个没有过时的构造器 Date(long date) 指定毫秒数
toString()：显示 年-月-日 `1971-02-13`

java.util.Date 转化为 java.sql.Date
先将 java.util.Date 转化为 时间戳，再用 java.sql.Date 的构造器
```java
java.util.Date utilDate = new java.util.Date();
long date = utilDate.getTime();
java.sql.Date sqlDate = new java.sql.Date(date);
```

### 23.4.3. SimpleDateFormat

java.text.SimpleDateFormat 类可以对日期 Date 类的做格式化和解析
格式化：日期 ---> 字符串
解析：字符串 ---> 日期，格式化的逆过程

默认构造器，默认格式化规则
```java
//实例化SimpleDateFormat:使用默认的构造器
SimpleDateFormat sdf = new SimpleDateFormat();

//格式化：日期 --->字符串
Date date = new Date();
System.out.println("toString:" + date);
// toString:Mon Aug 10 20:30:41 GMT+08:00 2020

String format = sdf.format(date);
System.out.println("format: "+format);
// format: 20-8-10 下午8:30

//解析：字符串 ---> 日期
String str = "19-12-18 上午11:43";
Date date1 = sdf.parse(str);
System.out.println("parse: "+date1);
// parse: Wed Dec 18 11:43:00 GMT+08:00 2019
```

带参构造器，自定义格式化规则
```java
SimpleDateFormat sdf1 = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss");
//格式化
Date date = new Date();
String format = sdf1.format(date);
System.out.println(format);
// 2020-08-10 08:34:39

//解析:要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)；否则，抛异常
Date date1 = sdf1.parse("2020-02-18 11:48:27");
System.out.println(date1);
// Tue Feb 18 11:48:27 GMT+08:00 2020
```

String ---> java.sql.Date ?
```java
SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
java.util.Date utilDate = format.parse("2020-09-08");
long date = utilDate.getTime();
java.sql.Date sqlDate = new java.sql.Date(date);
System.out.println(sqlDate);
```

### 23.4.4. java.util.Calendar 日历类

Calendar 是一个抽象类，不能被直接实例化。可以使用静态的 getInstance 方法获得一个实例 或者 实例化其子类 GregorianCalendar
```java
Calendar
    |-- java.util.GregorianCalendar 公历
        |-- sum.util.BuddhistCalendar 佛教的日历
```
getInstance 实际上也是创建了一个GregorianCalendar的对象。
```java
Calendar calendar = Calendar.getInstance();
System.out.println(calendar.getClass());
// class java.util.GregorianCalendar
```

Calendar 类中有一堆 public final static 修饰的常量：
YEAR, MONTH(一月是0), DAY_OF_WEEK(这一周的第几天, 周日是第一天), DAY_OF_MONTH(这个月中的第几天), DAY_OF_YEAR(这一年的第几天), HOUR_OF_DAY, MINUTE, SECOND。

int get(int field)：可以获得需要的时间信息。field 取值便是这些常量。
void set(int field, int value)：设置某个时间信息的值。
void add(int field, int amount)：给某个时间信息加上 amount，如果amount为负数则表示减。
final Date getTime()：Calendar --> java.util.Date
final void setTime(Date date)：java.util.Date --> Calendar

从 set 和 add 方法可见 Calendar 具有可变性。

### 23.4.5. LocalDate、LocalTime、LocalDateTime（jdk8 新增） 

[Date Time API](#217-date-time-api)


# 24. Java 8 新特性

## 24.1. 函数式接口
函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。
函数式接口可以被隐式转换为 lambda 表达式。

```java
@FunctionalInterface
interface GreetingService {
    void sayMessage(String message);
}
```

## 24.2. Lambda 表达式 
Lambda 表达式，也可称为闭包。允许把函数作为一个方法的参数（函数作为参数传递到方法中）。
当匿名内部类所实现的接口是一个函数式接口，可以使用Lambda表达式来替代。

主体部分可以是语句块或者一个表达式。（在 Java 中，一个表达式是不可以作为语句的）

```java
(parameters) -> { statements; }
(parameters) -> expression
```

- 类型声明可选：参数部分不需要声明类型，编译器可以识别。
- 当只有一个参数时，圆括号可以省略；0 个或多个参数不可以省略。
- 当主体只有一条语句时，大括号可以省略。（只有一条 return 语句不能省略大括号，除非按照下面这一条）
- 当主体只有一条语句，且是一个表达式时，return 可以省略，将表达式的值作为返回值。注意不能加大括号，加了大括号则必须有 return。

```java
public class LambdaTest {
    public static void main(String[] args){
        LambdaTest tester = new LambdaTest();

        // 参数类型声明，主体为表达式
        MathOperation addition = (int a, int b) -> a + b;

        // 参数不用类型声明，主体为表达式
        MathOperation subtraction = (a, b) -> (a - b);

        // 参数不用类型声明，主体为语句块
        MathOperation multiplication = (int a, int b) -> { return a * b; };

        // 参数类型声明，主体为语句块
        MathOperation division = (int a, int b) -> { int c =  a / b; return c; };

        System.out.println("10 + 5 = " + tester.operate(10, 5, addition));
        System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction));
        System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication));
        System.out.println("10 / 5 = " + tester.operate(10, 5, division));

        // 不用括号
        GreetingService greetService1 = message ->
        {
            System.out.println("Hello " + message);
        };

        // 用括号
        GreetingService greetService2 = (message) ->
                System.out.println("Hello " + message);

        greetService1.sayMessage("Runoob");
        greetService2.sayMessage("Google");
    }

    interface MathOperation {
        int operation(int a, int b);
    }

    interface GreetingService {
        void sayMessage(String message);
    }

    private int operate(int a, int b, MathOperation mathOperation){
        return mathOperation.operation(a, b);
    }
}
// 输出：
// 10 + 5 = 15
// 10 - 5 = 5
// 10 x 5 = 50
// 10 / 5 = 2
// Hello Runoob
// Hello Google
```

- 和匿名内部类一样，Lambda 表达式只能引用 final 所修饰的外层**局部变量**。
    原因：https://www.runoob.com/w3cnote/inner-lambda-final.html
    1.  内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。
    2. 当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在。这就存在一个问题：内部类对象访问了一个不存在的变量。
    3. 为了解决这个问题，方法中的局部变量实际上会被复制为内部类的成员变量使用。
    4. 所有为了保证这两个变量的一致性，内部类只能引用 final 修饰的局部变量。
    **程序设计语言的设计是受到实现技术的限制的。**

- 只是局部变量是final，成员变量可以改变。
- 可以不要 final 声明，但必须保证方法中的局部变量不能改变，即具有隐性的final语义。
- 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量

```java
public class LambdaFinal {
    String salutation = "Hello";

    public static void main(String[] args){
        new LambdaFinal().go();
    }

    void go() {
        int num = 1;
        GreetingService greetService1 = message -> System.out.println(salutation + num + message);

        //num = 2;
        // 如果改变了 num，则会报错
        // 从lambda 表达式引用的本地变量必须是最终变量或实际上的最终变量
        salutation = "你好";
        greetService1.sayMessage("Runoob");
    } 

    interface GreetingService {
        void sayMessage(String message);
    }
}
// 输出
// 你好1Runoob
```


## 24.3. 方法引用
方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。
方法引用提供了一种引用而不执行方法的方式。（函数指针？？）
**注意方法引用是一个Lambda表达式**
当Lambda表达式中仅调用了一个已存在的方法，可以使用方法引用来替代。

- 构造器引用：`类名::new` 或者 `Class<T>::new`
- 静态方法引用：`类名::静态方法名`
- 特定类的任意对象的方法引用：`类名::实例方法名`
- 特定对象的方法引用：`实例对象::方法名`


## 24.4. 接口实现类 - 匿名内部类 - Lambda表达式 - 方法引用

定义一个函数式接口
```java
@FunctionalInterface
public interface GreetingService {
    void sayMessage(String message);
}
```
类 GreetingController 依赖接口 GreetingService
```java
public class GreetingController {
    private GreetingService service;

    public void setService(GreetingService service) {
        this.service = service;
    }
    
    public void doService() {
        service.sayMessage("hello java 8");
    }
}
```

如果想要 GreetingController 正确工作，则必须要给他注入 GreetingService 接口的实现类。
```java
public class GreetingMain {
    public static void main(String[] args) {

        GreetingService service = null;

        GreetingController controller = new GreetingController();
        controller.setService(service);
        controller.doService();
    }
}
```

**方法一：接口实现类**
直接创建一个接口的实现类，并实例化这个实现类。
```java
public class GreetingServiceImpl implements GreetingService {
    @Override
    public void sayMessage(String message) {
        System.out.println(message);
    }
}
```
```java
public class GreetingMain {
    public static void main(String[] args) {

        GreetingService service = new GreetingServiceImpl();

        GreetingController controller = new GreetingController();
        controller.setService(service);
        controller.doService();
    }
}
```

**方法二：匿名内部类**
因为实现类只在这里使用一次，以后不会再使用了，可以用匿名内部类来替换。
```java
public class GreetingMain {
    public static void main(String[] args) {

        GreetingService service = new GreetingService() {
            @Override
            public void sayMessage(String message) {
                System.out.println(message);
            }
        };

        GreetingController controller = new GreetingController();
        controller.setService(service);
        controller.doService();
    }
}
```

**方法三：Lambda 表达式**
因为 GreetingService 接口中只有一个抽象函数，它是一个函数时接口，所有可以使用 Lambda 表达式。
```java
public class GreetingMain {
    public static void main(String[] args) {

        GreetingService service = (message) -> {
            System.out.println(message);
        };
        // GreetingService service = message -> System.out.println(message);

        GreetingController controller = new GreetingController();
        controller.setService(service);
        controller.doService();
    }
}
```

**方法四：方法引用**
因为再 Lambda 表达式中仅仅调用了一个已存在的方法，可以使用更简洁的方法引用。
```java
public class GreetingMain {
    public static void main(String[] args) {

        GreetingService service = System.out::println;

        GreetingController controller = new GreetingController();
        controller.setService(service);
        controller.doService();
    }
}
```



## 24.5. 默认方法
Java 8 新增了接口的默认方法。默认方法就是一个在接口里面有了一个实现的方法。
```java
public interface Vehicle {
   default void print(){
      System.out.println("我是一辆车!");
   }
}
```

**多个相同的默认方法**

如果一个类实现了多个接口，且这些接口有相同的默认方法。那么这个类必须重写默认方法，在默认方法中可以调用接口的默认方法。

如果一个类实现类一个接口，并继承了一个父类，接口的默认方法和父类的方法相同，则父类的方法生效。

**静态方法**
接口中还可以实现静态方法，接口中的静态方法只能通过`接口名.方法名()`的方式来访问。静态方法不会被其实现类继承。

```java
interface Vehicle {
    default void print(){
        System.out.println("我是一辆车!");
    }
    // 静态方法
    static void blowHorn(){
        System.out.println("按喇叭!!!");
    }
}

interface FourWheeler {
    default void print(){
        System.out.println("我是一辆四轮车!");
    }
}

class Car implements Vehicle, FourWheeler {
    @Override
    public void print(){
        System.out.println("Car 重写了默认方法");
        FourWheeler.super.print();
    }
}

class Box {
    public void print(){
        System.out.println("Box print");
    }
}

class Bus extends Box implements Vehicle {
}

class Mian {
    public static void main(String[] args) {
        Car car = new Car();
        car.print();

        Bus bus = new Bus();
        bus.print();

        Vehicle.blowHorn();
    }
}
```


## 24.6. Stream API
新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。

## 24.7. Date Time API
加强对日期与时间的处理。

在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：
- 非线程安全，java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。
- 设计很差，Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。
- 时区处理麻烦，日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。

Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：
- Local(本地) − 简化了日期时间的处理，没有时区的问题。
- Zoned(时区) − 通过制定的时区处理日期时间。

LocalDate、LocalTime、LocalDateTime
1. LocalDateTime相较于LocalDate、LocalTime，使用频率要高
2. 类似于Calendar
3. 三者都是线程安全的，具有不可变性。修改时会创建一个新的对象。
```java
// now(): 获取当前的日期、时间、日期+时间
LocalDate localDate = LocalDate.now();
LocalTime localTime = LocalTime.now();
LocalDateTime localDateTime = LocalDateTime.now();
System.out.println(localDate);
System.out.println(localTime);
System.out.println(localDateTime);
// 2020-08-10
// 21:24:45.121
// 2020-08-10T21:24:45.121

// of(): 设置指定的年、月、日、时、分、秒。没有偏移量
LocalDateTime localDateTime1 = LocalDateTime.of(2020, 10, 6, 13, 23, 43);
System.out.println(localDateTime1);
// 2020-10-06T13:23:43

//getXxx()：获取相关的属性
System.out.println(localDateTime.getDayOfMonth());
System.out.println(localDateTime.getDayOfWeek());
System.out.println(localDateTime.getMonth());
System.out.println(localDateTime.getMonthValue());
System.out.println(localDateTime.getMinute());
//        10
//        MONDAY
//        AUGUST
//        8
//        24

// 体现不可变性
// withXxx(): 设置相关的属性
LocalDate localDate1 = localDate.withDayOfMonth(22);
System.out.println(localDate);
System.out.println(localDate1);
//        2020-08-10
//        2020-08-22

LocalDateTime localDateTime2 = localDateTime.withHour(4);
System.out.println(localDateTime);
System.out.println(localDateTime2);
//        2020-08-10T21:24:45.121
//        2020-08-10T04:24:45.121

// 修改相关属性
LocalDateTime localDateTime3 = localDateTime.plusMonths(3);
System.out.println(localDateTime);
System.out.println(localDateTime3);
//        2020-08-10T21:24:45.121
//        2020-11-10T21:24:45.121

LocalDateTime localDateTime4 = localDateTime.minusDays(6);
System.out.println(localDateTime);
System.out.println(localDateTime4);
//        2020-08-10T21:24:45.121
//        2020-08-04T21:24:45.121
```


## 24.8. Optional 类
Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。
Optional 是个容器：它可以保存类型T的值，或者保存null。
Optional提供很多有用的方法，这样我们就不用显式进行空值检测。如果值存在则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。

```java
public final class Optional<T>
extends Object
```
常用方法（以下方法均省略 public）
```java
// 1、返回空的 Optional 实例。 return(Optional<T>) new Optional<>(null);
static <T> Optional<T> empty()

// 2、判断其他对象是否等于 Optional。
boolean equals(Object obj)

// 3、如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。
Optional<T> filter(Predicate<? super <T> predicate)

// 4、如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional
<U> Optional<U> flatMap(Function<? super T,Optional<U>> mapper)

// 5、如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException
T get()

//6、返回存在值的哈希码，如果值不存在 返回 0。
int hashCode()

// 7、如果值存在则使用该值调用 consumer , 否则不做任何事情。
void ifPresent(Consumer<? super T> consumer)

// 8、如果值存在则方法会返回true，否则返回 false。
boolean isPresent()

// 9、如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。
<U>Optional<U> map(Function<? super T,? extends U> mapper)

// 10、返回一个指定非null值的Optional。
static <T> Optional<T> of(T value)

// 11、如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。
static <T> Optional<T> ofNullable(T value)

// 12、如果存在该值，返回值， 否则返回 other。
T orElse(T other)

// 13、如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。
T orElseGet(Supplier<? extends T> other)

// 14、如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常
<X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier)

// 15、返回一个Optional的非空字符串，用来调试
String toString()
```


## 24.9. 新工具
新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。

## 24.10. Nashorn, JavaScript 引擎
Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。