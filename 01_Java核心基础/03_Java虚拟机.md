<h1 align="center">Java 虚拟机</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [JVM](#jvm)
- [1 Java 内存区域](#1-java-内存区域)
  - [1.1 JVM 运行时数据区](#11-jvm-运行时数据区)
    - [1.1.1 程序计数器 Program Counter Register](#111-程序计数器-program-counter-register)
    - [1.1.2 虚拟机栈 Java Virtual Machine Stacks](#112-虚拟机栈-java-virtual-machine-stacks)
    - [1.1.3 本地方法栈 Native Method Stacks](#113-本地方法栈-native-method-stacks)
    - [1.1.4 堆 Heap](#114-堆-heap)
    - [1.1.5 方法区 Method Area](#115-方法区-method-area)
    - [1.1.6 运行时常量池](#116-运行时常量池)
    - [1.1.7 直接内存](#117-直接内存)
  - [1.2 对象访问](#12-对象访问)
- [2 垃圾回收机制 GC](#2-垃圾回收机制-gc)
  - [2.1 如何判断对象已死](#21-如何判断对象已死)
    - [2.1.1 引用计数法 Reference Counting（Java 并不是）](#211-引用计数法-reference-countingjava-并不是)
    - [2.1.2 根搜索算法 GC Roots Tracing](#212-根搜索算法-gc-roots-tracing)
  - [2.2 引用](#22-引用)
    - [2.2.1 强引用](#221-强引用)
    - [2.2.2 软引用](#222-软引用)
    - [2.2.3 弱引用](#223-弱引用)
    - [2.2.4 虚引用](#224-虚引用)
  - [2.3 GC 是如何回收对象](#23-gc-是如何回收对象)
    - [2.3.1 finalize()方法](#231-finalize方法)
    - [2.3.2 方法区垃圾回收](#232-方法区垃圾回收)
  - [2.4 垃圾收集算法](#24-垃圾收集算法)
    - [2.4.1 标记 — 清除算法](#241-标记-清除算法)
    - [2.4.2 复制算法](#242-复制算法)
    - [2.4.3 标记 — 整理算法](#243-标记-整理算法)
    - [2.4.4 分代收集算法](#244-分代收集算法)
  - [2.5 垃圾收集器](#25-垃圾收集器)
    - [2.5.1 Serial](#251-serial)
    - [2.5.2 ParNew](#252-parnew)
    - [2.5.3 Parallel Scavenge](#253-parallel-scavenge)
    - [2.5.4 Serial Old](#254-serial-old)
    - [2.5.5 Parallel Old](#255-parallel-old)
    - [2.5.6 CMS](#256-cms)
    - [2.5.7 G1](#257-g1)
  - [2.6 内存分配策略](#26-内存分配策略)
- [3 类文件结构](#3-类文件结构)
  - [3.1 Class 类文件结构](#31-class-类文件结构)
- [4 类加载机制](#4-类加载机制)
  - [4.1 类的生命周期](#41-类的生命周期)
  - [4.2 触发类的初始化](#42-触发类的初始化)
  - [4.3 类加载的过程](#43-类加载的过程)
  - [4.4 类加载器](#44-类加载器)
    - [双亲委派模型](#双亲委派模型)
- [5 虚拟机字节码执行引擎](#5-虚拟机字节码执行引擎)
  - [5.1 运行时栈帧结构](#51-运行时栈帧结构)
  - [5.2 方法调用](#52-方法调用)
    - [5.2.1 解析](#521-解析)
    - [5.2.2 分派](#522-分派)
  - [5.3 基于栈的指令集和基于寄存器的指令集](#53-基于栈的指令集和基于寄存器的指令集)
- [6 高效并发](#6-高效并发)
  - [6.1 指令重排序](#61-指令重排序)
  - [6.2 Java 内存模型与线程](#62-java-内存模型与线程)
    - [6.2.1 主内存与工作内存](#621-主内存与工作内存)
    - [6.2.2 内存间交互操作](#622-内存间交互操作)
    - [6.2.3 volatile](#623-volatile)
    - [6.2.4 原子性、可见性和有序性](#624-原子性-可见性和有序性)
    - [6.2.5 先行发生原则](#625-先行发生原则)
  - [6.3 Java 与线程](#63-java-与线程)
    - [6.3.1 线程的实现](#631-线程的实现)
    - [6.3.2 Java 线程调度](#632-java-线程调度)
  - [6.4 线程安全](#64-线程安全)
    - [6.4.1 线程安全的实现方法](#641-线程安全的实现方法)
- [7 锁优化](#7-锁优化)

<!-- /code_chunk_output -->

# JVM
JVM 包括：一套字节码指令集、一组寄存器、一个垃圾回收、一个栈、堆、一个存储方法域。JVM 是运行在操作系统之上的，它与硬件没有直接 的交互。 


# 1 Java 内存区域

## 1.1 JVM 运行时数据区

![image-20200319191553417](/images/image-20200319191553417.png)

### 1.1.1 程序计数器 Program Counter Register

类似于计算机组成原理中的程序计数器 PC。它的作用可以看作是当前线程所执行的字节码的行号指示器。唯一一个不会导致内存泄漏的内存区域。

程序计数器是线程私有的，各个线程之间独立拥有一个程序计数器，互不影响。

### 1.1.2 虚拟机栈 Java Virtual Machine Stacks

线程私有的

会产生```StackOverflowError```和```OutOfMemoryError```错误。

设置JVM参数 **-Xss228k**（栈大小为228k）

### 1.1.3 本地方法栈 Native Method Stacks

会产生```StackOverflowError```和```OutOfMemoryError```错误。

程序计数器、虚拟机栈、本地方法栈随线程而生而灭。

本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 **C 栈**。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

### 1.1.4 堆 Heap

被所有线程所共享的，再虚拟机启动时被创建。

用于存放对象实例。

堆是垃圾收集器管理的主要区域。也被称为 GC 堆。

可以细分为：新生代和老年代。

**-Xms20M  -Xmx20M**（前者表示初始堆大小20M，后者表示最大堆大小20M）

会产生```OutOfMemoryError```错误。

### 1.1.5 方法区 Method Area

被所有线程所共享的。

用于存储：已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。

别名：Non-Heap

会产生```OutOfMemoryError```错误。

### 1.1.6 运行时常量池

属于方法区的一部分，用于存放：编译期生成的各种字面量和符号引用

会产生```OutOfMemoryError```错误。

### 1.1.7 直接内存

直接内存是除 Java 虚拟机之外的内存，但也可能被 Java 使用。

## 1.2 对象访问

1. 句柄  
![image-20200319194643432](/images/image-20200319194643432.png)

2. 直接指针  
![image-20200319194702842](/images/image-20200319194702842.png)



# 2 垃圾回收机制 GC

## 2.1 如何判断对象已死

### 2.1.1 引用计数法 Reference Counting（Java 并不是）

微软的 COM 是

算法：给对象添加一个引用计数器，每次被引用时，计数器自增；当引用失效时，计数器自减。计数器的值为0的对象不能被再次使用。

无法解决：对象之间相互循环引用的问题。

### 2.1.2 根搜索算法 GC Roots Tracing

Java、C#、Lisp 是

算法：通过一系列名为 "GC Roots" 的对象作为起点，开始向下搜索。当从 GC Roots 到一个对象不可达时，则该对象是不可用的。这就解决了对象之间形成闭环的问题。

GC Roots 包括：

1. 虚拟机栈中的引用的对象
2. 本地方法栈中 JNI 的引用的对象
3. 方法区中类静态属性引用的对象
4. 方法区中常量引用的对象

**【我的思考】：那么对于单例对象呢？自身形成闭环怎么处理的。**

答：单例对象由自身类的静态属性所引用。

## 2.2 引用

### 2.2.1 强引用

像 ```Integer i = new Integer()```这种的。

GC 永远也不会回收强引用的对象。

### 2.2.2 软引用

再系统将要内存溢出时，不会马上回收软引用的对象，只会把软引用的对象列入第二次回收的清单当中。如果第一次回收结束后还是没有足够内存，会进行第二次回收，回收软引用对象。

JDK 1.2 之后，使用 ```SoftReference``` 类来实现

### 2.2.3 弱引用

弱引用的对象会在接下来的一次垃圾回收的时候被清理掉。

JDK 1.2 之后，使用 ```WeakReference``` 类来实现

### 2.2.4 虚引用

**虚引用和上述三者不是并列关系**，前三者和对象的生命周期密切相关。而虚引用的目的是为了在这个对象被回收时得到一个系统消息，不会改变对象的生命周期。

JDK 1.2 之后，使用 ```PhantomReference``` 类来实现



## 2.3 GC 是如何回收对象

### 2.3.1 finalize()方法

当一个对象没有重写```finalize()```方法，或者```finalize()```方法已经被执行过一次 都不会执行```finalize()```方法。

任何一个对象的```finalize()```方法都只会被系统自动调用一次，在下一次垃圾回收时```finalize()```方法不会被再次执行。

### 2.3.2 方法区垃圾回收

主要回收：废弃常量 和 无用的类

判断是否为废弃常量：

1. 该类所有的实例都已不存在
2. 加载该类的 ClassLoader 已经被回收
3. 该类对于的 Class 对象没有在任何地方被引用，无法通过反射来访问该类

## 2.4 垃圾收集算法

### 2.4.1 标记 — 清除算法

算法：先标记出需要回收的对象，然后统一回收所有被标记的对象。

缺点：

1. 标记和清除的效率都不高
2. 清除之后会产生大量不连续的内存碎片

### 2.4.2 复制算法

算法：将可用内存分为等量的两块，每次只在其中一块内存上分配对象的空间，另一块内存全部未使用。当第一块内存用完之后，把还需要的对象依次拷贝到第二块内存中，然后把第一块内存全部回收。

解决了：内存碎片的问题

优点：实现简单、运行高效

缺点：将可用内存缩小为了原来的一半

用来回收新生代，将内存分为一块较大的和两块较小的。每次使用一块大的和一块小的，回收时，将需要的对象拷贝到另一块小的上面，清理另外两块。比例默认是 8 : 1 : 1。

### 2.4.3 标记 — 整理算法

算法：先标记出要被回收的对象，然后将所有存活的对象都向堆的一边移动，清理掉边界之外的内存。

**很像数组中删除中间某个元素：后一个元素不断往前拷贝，最后一个元素置为 null。**

### 2.4.4 分代收集算法

算法：将内存分为新生代和老年代。新生代中的对象存活期短，每次标记时会有大量对象死去，采用复制算法清理；老年代对象存活较久，可以使用 标记 — 清除算法 或 标记 — 整理 算法。

## 2.5 垃圾收集器

![image-20200319212916442](/images/image-20200319212916442.png)

连线表示两个收集器可以搭配使用。

### 2.5.1 Serial

新生代、单线程 的收集器。在它工作时必须暂停其他线程（Stop The World）。

优点：简单高效

适合：Client 模式下新生代收集器。

![image-20200319213437238](/images/image-20200319213437238.png)

### 2.5.2 ParNew

Serial 的多线程版本。也会有 Stop The World。

适合：Server 模式下新生代收集器。

![image-20200319213446924](/images/image-20200319213446924.png)

### 2.5.3 Parallel Scavenge

使用复制算法、并行的 多线程、新生代 收集器。

目标：达到一个可控制的吞吐量，吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)。即就是，尽可能缩短垃圾回收的时间。

![image-20200319215013138](/images/image-20200319215013138.png)

### 2.5.4 Serial Old

Serial 的老年代版本，单线程，使用 标记 — 整理 法。

适合：Client 模式下老年代收集器，jdk 1.5 以及之前 Server 模式和 Parallel Scavenge 搭配，作为 CMS 的后备。

![image-20200319213437238](/images/image-20200319213437238.png)

### 2.5.5 Parallel Old

Parallel Scavenge 的老年代版本，多线程，使用 标记 — 整理 法。

![image-20200319215013138](/images/image-20200319215013138.png)

### 2.5.6 CMS

以获得最短回收停顿时间为目标，基于 标记 — 清除 算法。

四个步骤：

1. 初始标记：标记一下 GC Roots 能够直接关联到的对象（速度很快）
2. 并发标记：执行 GC Roots Tracing
3. 重新标记：修正并发标记期间，因用户程序运行而产生的变动（比初始标记稍长，但远短于并发标记的时间）
4. 并发清除

初始标记 和 重新标记 仍然会 Stop The World。

优点：并发收集、低停顿

缺点：

- CMS 对 CPU 资源非常敏感
- 无法处理浮动垃圾
- 使用了 标记 — 清除 算法，会产生大量内存碎片

![image-20200319215720204](/images/image-20200319215720204.png)

### 2.5.7 G1

相对CMS的改进：

- 基于 标记 — 整理 算法
- 它可以非常准确地控制停顿

## 2.6 内存分配策略

1. **对象优先分配在新生代**

2. **需要大量连续内存的对象分配到老年代**
3. **长期存活的对象将进入老年代**

当一个对象在新生代每经过一次 GC，年龄加一，当到15岁时进入老年代。

4. **动态年龄判定**

当新生代中相同年龄的对象大小之和大于内存空间一半时，年龄大于或等于该年龄的对象直接进入老年代。

5. **空间分配担保**

![image-20200319221452552](/images/image-20200319221452552.png)



# 3 类文件结构

## 3.1 Class 类文件结构

Java 虚拟机具有语言无关性。只要是符合 Java 虚拟机规范的字节码文件，就可以被虚拟机执行。

Java 虚拟机具有平台无关性。不同操作系统上都有相应的虚拟机版本。



1. 魔数：Class 文件前4字节，用来标识 Class 文件。值为，0xCAFEBASE。

2. 版本号：接下来的4字节，第5、6字节是次版本号，第7、8字节是主版本号。
3. 常量池入口：紧后的2字节

常量池中存放：字面量和符号引用；符号引用包括：类和接口的全限定名、字段的名称和描述符

、方法的名称和描述符。



# 4 类加载机制

## 4.1 类的生命周期

类的整个生命周期 (7阶段)：加载 (Loading)、验证 (Verification)、准备 (Preparation)、解析 (Resolution)、初始化 (Initialization)、使用 (Using)、卸载 (Unloading)。

![image-20200321162436004](/images/image-20200321162436004.png) 

## 4.2 触发类的初始化

![image-20200321162806300](/images/image-20200321162806300.png)

## 4.3 类加载的过程

(1) 加载阶段，虚拟机要完成以下3件事情：

1. 通过类的全限定名，获取其二进制字节流
2. 将该字节流的静态存储结构转化为方法区的运行时数据结构
3. 在堆中生成一个代表该类的 java.lang.Class 对象，作为方法区的数据的访问入口

(2) 验证阶段，四个验证

1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证

(3) 准备阶段：为类变量分配内存并设置初始值

(4) 解析阶段：将常量池中的符号引用替换为直接引用的过程

![image-20200321163809920](/images/image-20200321163809920.png)

(5) 解析阶段

1. 类或接口的解析
2. 字段解析
3. 类方法解析
4. 接口方法解析

(6) 初始化阶段：类加载的最后一步



![image-20200321164156083](/images/image-20200321164156083.png)



## 4.4 类加载器

###  双亲委派模型

Java虚拟机角度分：两种不同的类加载器：

1. 启动类加载器 (Bootstrap ClassLoader)，由C++实现，是虚拟机自身的一部分
2. 所有其他的类加载器，由Java实现，独立于虚拟机之外，全部继承自java.lang.ClassLoader

程序员角度分：三种系统提供的类加载器：

1. 启动类加载器 (Bootstrap ClassLoader)
2. 拓展类加载器 (Extension ClassLoader)
3. 应用程序类加载器 (Application ClassLoader)

![image-20200321165440524](/images/image-20200321165440524.png)

双亲委派模型要求除了启动类加载器外，其余的都需要有父类加载器。但不会使用继承，而是使用组合关系来实现。

双亲委派的工作过程：当一个类收到了类加载请求时，会先委派给父类加载器去完成，每层都会传递加载请求。只有当父类加载器无法完成时，子类加载器才会尝试去做。

# 5 虚拟机字节码执行引擎

1. 解释执行：通过解释器执行
2. 编译执行：通过即时编译器产生本地代码执行

## 5.1 运行时栈帧结构

栈帧是虚拟机运行时数据区中的虚拟机栈的栈元素。

栈帧中存储了：方法的局部变量表、操作数栈、动态链接、方法返回地址等信息。

当前栈帧：栈顶的栈帧。所关联的方法称为当前方法



局部变量表的容量以变量槽为最小单位。

退出方法的两种方式：

1. 正常完成出口：遇到方法返回的字节码指令
2. 异常完成出口：遇到异常，且异常没有在方法中处理

## 5.2 方法调用

方法调用并不等于方法执行。方法调用阶段的唯一任务是：确定被调用方法的版本，即调用哪一个方法。

### 5.2.1 解析

解析：如果当方法的调用版本在运行期间是不可改变的，那么在类加载阶段，会把一部分符号引用转化为直接引用。

编译器可知，运行期不可变 — 静态方法和私有方法。这两种方法都不能被重写。

### 5.2.2 分派

- **静态分派**：所有依赖静态类型来定位方法执行版本的分派动作，方法重载。静态分派发生在编译期间。

编译器在决定使用那个重载方法时是通过参数的静态类型来做判断的。

```java
public class MethodTest {
    public static void main(String[] args) {
        int a = 0;
        method(a);
    }
	
    // 以下五个方法按照调用选择顺序排列
	//方法1
    public static void method(int a){
        System.out.println("执行method(int a)");
    }
    //方法2
    public static void method(long a){
        System.out.println("执行method(long a)");
    }
    //方法3
    public static void method(Integer a) {
        System.out.println("执行method(Integer a)");
    }
    //方法4
    public static void method(Object a) {
        System.out.println("执行method(Object a)");
    }
    //方法5
    public static void method(int...a) {
        System.out.println("执行method(int...a)");
    }
}


class A {
    public static void method(int a){
        System.out.println("A类中的method()");
    }
}
public class MethodTest2 extends A{
    //方法4
    public static void method(Object a) {
        System.out.println("执行method(Object a)");
    }
    //方法5
    public static void method(int...a) {
        System.out.println("执行method(int...a)");
    }
    public static void main(String[] args) {
        int a = 0;
        method(a);
    }
}
```

关于方法重载时的调用选择我们可以得出以下结论：

(1)   精确匹配：对于上述代码中，当有method(int a)存在时调用的肯定就是这个方法；

(2)   自动类型提升：对于基础数据类型，自动转成表示范围更大的类型；当方法1被注释的时候，会去调用method(long a)而不是method(Integer a)；

(3)   自动装箱与拆箱：当方法1，2被注释，就调用方法3；

(4)   根据子类依次向上继承路线匹配：当只有方法4与方法5时，先找int的父类，找到的object类型，匹配之后调用；当继承A类之后，由于本类没有合适的方法，然后就去A类中找，匹配调用（A类中方法参数类型换成long，Integer结果也一样）；

(5)   根据可变参数匹配。

引用自：https://www.jianshu.com/p/306c4bfe3f54



- **动态分派**：方法重写

通过方法的接收者来决定使用那个方法。

Java 中其实没有虚函数的概念，它的普通函数就相当于 C++ 的虚函数，**动态绑定**是Java的默认行为。如果 Java 中不希望某个函数具有虚函数特性，可以加上 final 关键字变成非虚函数。



- **单分派与多分派**：

方法的宗量：方法的接收者与方法的参数统称为方法的宗量。

Java 语言：静态多分派，动态单分派。

C# 3.0 以前和 Java 一样，4.0 引入了 dynamic 类型后，实现了动态多分派。

![image-20200321185141401](/images/image-20200321185141401.png)

## 5.3 基于栈的指令集和基于寄存器的指令集

Java 编译器输出的指令流基本上是一种基于栈的指令集架构。

基于栈：

​	优点：可移植性，代码相对更紧凑，编译器实现更简单

​	缺点：执行速度相对稍慢

# 6 高效并发

## 6.1 指令重排序

![image-20200324202935391](/images/image-20200324202935391.png)

## 6.2 Java 内存模型与线程

### 6.2.1 主内存与工作内存

以下涉及到的**变量**均专指：实例字段、静态字段、构成数组对象的元素，是可以被多个线程共享的。

局部变量和方法参数是线程私有的，不会被共享。

所有的变量都存储在主内存中，此外，每条线程都有自己的工作内存。在工作内存中保存了被该线程使用到的变量的主内存的副本。线程对变量的操作只能在工作内存中进行，不能直接操作主内存中的变量。

**哦 ~ ，那 volatile 变量 和 直接内存！**

![image-20200324204556331](/images/image-20200324204556331.png)

### 6.2.2 内存间交互操作

作用于主内存的变量：

1. lock 锁定：把一个变量标识位一条线程独占的状态
2. unlock 解锁：释放处于锁定状态的变量
3. read 读取：把一个变量从主内存传输到线程的工作内存中，以便随后的 load 操作使用
4. write 写入：把 store 操作从工作内存中得到的变量的值，放入主内存的变量中

作用于工作内存的变量

5. load 载入：把 read 操作从主内存中得到的变量的值，放入工作内存的变量副本中
6. use 使用：把工作内存中一个变量的值传递给执行引擎（每当遇到一个需要使用变量的值的字节码指令时，虚拟机会执行这个操作）
7. assign 赋值：把一个从执行引擎接受到的值赋值给工作内存的变量（每当遇到一个给变量赋值的字节码指令时，虚拟机会执行这个操作）
8. store 存储：把工作内存中的一个变量的值传输到主内存中，以便随后的 write 操作使用

![image-20200324205933996](/images/image-20200324205933996.png)



![image-20200324210114109](/images/image-20200324210114109.png)

### 6.2.3 volatile

volatile 变量的特性：

1. 保证该变量对所有线程可见
2. 禁止指令重排序优化

【《深入理解Java虚拟机》332 页 代码清单 12-7】

![image-20200324215527107](/images/image-20200324215527107.png)

### 6.2.4 原子性、可见性和有序性

**原子性**：Java 内存模型中来直接保证原子性的变量操作包括 read、load、assign、use、store、write。我们认为基本数据类型的访问读写是具备原子性的。在 synchronized 块之间的操作也具备原子性。

*非原子的 64 位操作：没有被声明位 volatile 的 64 位数值变量 (double、long)，JVM 允许将64位的读写划分为两个 32 位操作。*

**可见性**：是指当一个线程修改了共享变量的值，其他线程能够立即得知。

**有序性**：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句指："线程内表现位串行的语义"，后半句指："指令重排序"现象和"工作内存与主内存同步延迟"现象。

### 6.2.5 先行发生原则

![image-20200324220021374](/images/image-20200324220021374.png)

![image-20200324220241828](/images/image-20200324220241828.png)

时间上的先后顺序与先行发生原则之间基本没有太大关系，所以**我们衡量并发安全问题的时候**不要受到时间顺序的干扰，**一切必须以先行发生原则为准**。

并发并不一定要依赖多线程，如 PHP 中常见的**多进程**并发。

## 6.3 Java 与线程

### 6.3.1 线程的实现

**1. 使用内核线程实现**

内核线程就是直接由操作系统内核支持的线程，这种线程由内核来进行线程调度。

**2. 使用用户线程实现**

![image-20200324222401487](/images/image-20200324222401487.png)

**3. 使用用户线程加轻量级进程混合实现**

### 6.3.2 Java 线程调度

**6 种状态**：

1. 新建 New：创建后尚未启动

2. 运行 Runable：包括操作系统中的 Running 和 Ready，即执行态和就绪态

3. 无期限等待 Waiting：这种状态的线程不会被分配CPU，要等待被其他线程显式地唤醒

   三种方法进入这个状态：

   1、没有设置 Timeout 的 Object.wait() 方法  

   2、没有设置 Timeout 的 Thread.join() 方法

   3、LockSupport.park() 方法

4. 期限等待 Timed Waiting：这种状态的线程不会被分配CPU，在一定时间后被系统唤醒

   五种方法进入这个状态：

   1、设置 Timeout 了的 Object.wait() 方法  

   2、设置 Timeout 了的 Thread.join() 方法

   3、Thread.sleep() 方法

   4、LockSupport.parkNanos() 方法

   5、LockSupport.parkUntil() 方法

5. 阻塞 Blocked：等待一个排它锁

6. 结束 Terminated：线程已经执行结束

![image-20200326203103878](/images/image-20200326203103878.png)

## 6.4 线程安全

按照线程安全的安全程度分：

1. 不可变：final，java.lang.String的对象是不可变对象
2. 绝对线程安全：不论何种环境下，不需要做任何额外同步措施
3. 相对线程安全：使用额外的同步手段保证调用的正确性
4. 线程兼容：对象本身不是线程安全的，可以通过调用段使用同步手段来保证对象安全
5. 线程对立：不管采用哪种方式，都不能并发的使用。

### 6.4.1 线程安全的实现方法

**1、互斥同步**

同步：在多个线程并发访问共享数据时，保证共享数据在同一时刻只被一条线程使用。

互斥：是实现同步的方法。有 临界区、互斥量、信号量。

【synchronized 重量级锁】

![image-20200326203653161](/images/image-20200326203653161.png)

1. synchronized 是可以重进入的。
2. 当有其他线程访问同步块会被阻塞。阻塞或者唤醒一条线程涉及到用户态转换为核心态。

【ReentrantLock 重入锁】

比 synchronized 增加了一些高级功能

1. 等待可中断：当锁长期不被释放时，等待的线程可以选择放弃等待

2. 可实现公平锁：

   公平锁：必须按照申请锁的先后顺序来活得锁

   非公平锁：在锁被释放时，任何一个等待线程都有机会获得

   synchronized 是非公平，ReentrantLock 默认非公平，可由构造函数指定使用公平锁

3. 锁可以绑定多个条件：一个 ReentrantLock 对象可以同时绑定多个 Condition 对象

![image-20200326204817398](/images/image-20200326204817398.png)

**2、非阻塞同步**

互斥同步也叫做阻塞同步，它在阻塞和唤醒线程时会带来性能问题。

操作和冲突检测具备原子性，由硬件支持。

![image-20200326205209303](/images/image-20200326205209303.png)

【比较并交换 CAS】jdk1.5 之后

这个指令需要三个操作数：内存位置 V，旧的预期值 A，新值 B。

当且仅当 V 的值 符合 A 时，CPU 用 B 更新 V 的值，否则不更新；但都会返回 V 的旧值。

J.U.C 包中的整数原子类即使用了 CAS 操作

![image-20200326210140921](/images/image-20200326210140921.png) 

**3、无同步方案**

可重入代码一定线程安全。

线程本地存储

# 7 锁优化

【自旋锁】

![image-20200326213802024](/images/image-20200326213802024.png)

自适应的自旋锁

![image-20200326214052289](/images/image-20200326214052289.png)

【锁消除】

虚拟机即时编译器在运行时，对一些代码上要求同步的，但被检测到没有共享数据竞争的锁进行消除，即编译器优化。

【锁粗化】

将相邻的一些可以被合并的锁给合并。

【偏向锁】—【轻量级锁】—【重量级锁】

![image-20200413162304323](/images/image-20200413162304323.png) 