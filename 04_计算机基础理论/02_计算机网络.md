<h1 id="计算机网络" align="center">计算机网络</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. 从一个 URL 链接开始](#1-从一个-url-链接开始)
  - [1.1. 解析链接的各个部分含义](#11-解析链接的各个部分含义)
  - [1.2. 输入 url 到 显示网页的全过程](#12-输入-url-到-显示网页的全过程)
- [2. 网络分层模型](#2-网络分层模型)
  - [2.1. HTTP/TCP/IP 组成字段](#21-httptcpip-组成字段)
- [3. 网络层与 IP 协议](#3-网络层与-ip-协议)
  - [3.1. IP 地址](#31-ip-地址)
  - [3.2. 网际协议 IP](#32-网际协议-ip)
- [4. 运输层与 TCP 协议](#4-运输层与-tcp-协议)
  - [4.1. 端口](#41-端口)
  - [4.2. TCP 与 UDP 比较](#42-tcp-与-udp-比较)
  - [4.3. 可靠传输原理](#43-可靠传输原理)
    - [4.3.1. 停止等待协议](#431-停止等待协议)
    - [4.3.2. 连续 ARQ 协议](#432-连续-arq-协议)
  - [4.4. TCP](#44-tcp)
    - [4.4.1. TCP 三次握手](#441-tcp-三次握手)
    - [4.4.2. TCP 四次挥手](#442-tcp-四次挥手)
    - [4.4.3. 滑动窗口协议](#443-滑动窗口协议)
    - [4.4.4. 流量控制](#444-流量控制)
    - [4.4.5. 拥塞控制](#445-拥塞控制)
- [5. 应用层与 HTTP 协议](#5-应用层与-http-协议)
  - [5.1. 资源](#51-资源)
    - [5.1.1. 媒体类型 MIME](#511-媒体类型-mime)
    - [5.1.2. URI](#512-uri)
      - [5.1.2.1. URL](#5121-url)
      - [5.1.2.2. URN](#5122-urn)
  - [5.2. HTTP 协议](#52-http-协议)
    - [5.2.1. HTTP 事务](#521-http-事务)
      - [5.2.1.1. 请求方法](#5211-请求方法)
      - [5.2.1.2. 响应状态码](#5212-响应状态码)
    - [5.2.2. HTTP 报文](#522-http-报文)
      - [5.2.2.1. 首部字段](#5221-首部字段)
    - [5.2.3. HTTPS](#523-https)
      - [5.2.3.1. SSL握手](#5231-ssl握手)

<!-- /code_chunk_output -->


# 1. 从一个 URL 链接开始

## 1.1. 解析链接的各个部分含义

```url
https://www.nowcoder.com/discuss/372819?type=all&order=time&pos=&page=6&channel=0&source_id=search_all
```
协议://主机名:端口号/目录/文件名.文件后缀?参数=值&参数=值#标志

**协议**
http、https、file、ftp

**主机名**
主机名可以是一个域名或者一个IP地址，在主机名前面也可以带上连接主机的用户名和密码：
`用户名:密码@子域名.域名.顶级域名.根域名`
一般见到的域名就只有到顶级域名，根域名很少，例如：`http://www.ncu.edu.cn/`

**端口号**
如果使用协议的默认端口号，则可以省略。

**查询字符串 Query String**
以 ? 开始一个查询字符串，以 k=v 的形式表示参数，多个参数之间使用 & 连接。

**锚点**
`#` 2. 代表网页中的一个位置（锚点）。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。
锚点不会被提交，锚点是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括`#`。

## 1.2. 输入 url 到 显示网页的全过程

![img](https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageslim)

0. 客户端访问本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找本地的DNS服务器
1. 浏览器向DNS域名服务器请求解析域名为 IP 地址（迭代查询、递归查询）。
2. 建立 TCP 连接
3. 浏览器向目标服务器发起一个 HTTP 请求，cookies 会随之发送过去。
4. 在运输层通过TCP协议进行数据封装，把一个HTTP会话请求分为若干报文段，添加源端口和目的端口。
5. 网络层则把TCP报文段，划分为不同分组，每个分组各自进行路由选择，最终到达服务器。为确保分组的顺序不乱，需要在发送前给每个分组编号。
6. 服务器收到浏览器的请求后，便会进行逻辑处理，发回一个 HTML 响应。
7. 浏览器接受到 HTML 文件后，进行渲染显示。

**[html 渲染](https://blog.csdn.net/xzm_0602/article/details/53231348)**
1. 下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。 
2. 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。
3. 如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时下载过程会启用单独连接进行下载。 
4. 样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。 
5. JS、CSS中如有重定义，后定义函数将覆盖前定义函数。

**reflow（回流）**
浏览器要花时间、花精力去渲染页面，当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。 
reflow 几乎是无法避免的。只要引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。 当 然，reflow 问题是可以优化的，我们可以尽量减少不必要的 reflow。比如例子中的 <img> 图片载入问题 —— 给图片设置宽度和高度就可以避免的 reflow。这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。
**repaint（重绘）**
repaint，中文叫重绘。如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint。


# 2. 网络分层模型

- OSI 7层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
- TCP/IP 4层：网络接口层、网际层(IP)、运输层(TCP)、应用层(HTTP)。
- 5 层：物理层、数据链路层、网络层、运输层、应用层。

各层协议：
- 物理层：RJ45、CLOCK、IEEE802.3   （中继器，集线器，网关） 
- 数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） 
- 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 
- 传输层：TCP、UDP、SPX 
- 会话层：NFS、SQL、NETBIOS、RPC 
- 表示层：JPEG、MPEG、ASII 
- 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

各层作用：
- 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）  
- 数据链路层：将比特组装成帧和点到点的传递（帧Frame）  
- 网络层：负责数据包从源到宿的传递和网际互连（包Package）  
- 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）  
- 会话层：建立、管理和终止会话（会话协议数据单元SPDU）  
- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）  
- 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

![七层体系结构图](https://user-gold-cdn.xitu.io/2018/7/29/164e529309f0fa33?imageslim)


**物理层**
单工通信：单向传输
半双工通信：双向交替传输
全双工通信：双向同时传输

**数据链路层**
数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。
在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报**封装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。


## 2.1. HTTP/TCP/IP 组成字段
![](/images/HTTP报文TCP段IP分组.png)
![](/images/IPTCPHTTP首部字段.png)


# 3. 网络层与 IP 协议

网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成**分组**和**包**进行传送

**网络层向上只提供灵活的、无连接的、尽最大努力交付的数据报服务。**

在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫**IP数据报**，简称数据报。

互联网是由大量的**异构**（heterogeneous）网络通过**路由器**（router）相互连接起来的。互联网使用的网络层协议是**无连接**的**网际协议（Intert Prococol）**和许多路由选择协议，因此互联网的网络层也叫做**网际层**或**IP层**。


## 3.1. IP 地址

A 类地址：以 0 开头，1.0.0.0~126.255.255.255，前一字节做网络号
B 类地址：以 10 开头，128.1.0.0~191.255.255.255，前两字节做网络号
C 类地址：以 110 开头，192.0.1.0~223.255.255.255，前三字节做网络号
D 类地址：以 1110 开头，224.0.0.0~239.255.255.255，多播地址
E 类地址：以 1111 开头，240.0.0.0~247.255.255.255保留地址

私网地址：10.0.0.0 - 10.255.255.255，172.16.0.0 - 172.31.255.255，192.168.0.0 - 192.168.255.255。

![image-20200330195231897](/images/image-20200330195231897.png)
![image-20200330195424406](/images/image-20200330195424406.png)

## 3.2. 网际协议 IP

![](/images/IP及其配套协议.png)


# 4. 运输层与 TCP 协议

运输层的主要任务就是负责向两台主机**进程**之间的通信提供通用的数据传输服务，端到端的通讯。

运输层：提供端到端（进程到进程）的通讯。属于面向通信部分的最高层，用户功能中的最底层。
只有主机的协议栈才用运输层，路由器最高只到网络层。

## 4.1. 端口

```text
端口号（16位）
  |-- 服务器端使用的端口号
        |-- 熟知端口号/系统端口号 0 - 1023
        |-- 登记端口号 1024 - 49151
  |-- 客户器端使用的端口号 49151 - 65535
```

**套接字 = IP地址:端口号**

## 4.2. TCP 与 UDP 比较

传输控制协议 (Transmission Control Protocol)：面向连接的，可靠的。

1. TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
2. TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且**按序**到达；
3. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
4. 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

5. TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；

**TCP一般用于文件传输（FTP）、发送和接收邮件（SMTP）、远程登录（Telnet）等场景。**


用户数据协议 (User Datagram Protocol)：面向无连接的，不保证数据传输的可靠性，尽最大努力传输数据。

1. UDP是无连接的；
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
3. UDP支持一对一、一对多、多对一和多对多的交互通信；
4. UDP是面向报文的；

5. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； 
6. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

**虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信），比如： QQ语音 QQ视频 、直播等等**

![TCP、UDP协议的区别](https://user-gold-cdn.xitu.io/2018/4/19/162db5e97e9a9e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


**面向连接和非面向连接的服务的特点是什么？**

面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。 
非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。

## 4.3. 可靠传输原理

### 4.3.1. 停止等待协议

- 停止等待协议：每发送完一个分组就停止发送，等待对方确认；在收到确认后再发送下一个分组。
- 超时重传：超时的时间应该比分组的平均往返时延稍长一些。
- 缺点：信道利用率低。

### 4.3.2. 连续 ARQ 协议

- 发送方维护一个发送窗口，一次性发送掉在发送窗口内的所有分组。
- 接收方采用累积确认的方式，对按序到达的最后一个分组发送确认报文。
- 缺点：Go-back-N：当某个分组丢失时，其后面的所有分组都要重传。


## 4.4. TCP

### 4.4.1. TCP 三次握手

![image-20200330202647661](/images/image-20200330202647661.png)

- 第一次握手：客户端发送带有 SYN 标志的数据包给服务器。
- 第二次握手：服务器发送带有 SYN/ACK 标志的数据包给客户端。
- 第三次握手：客户端发送带有 ACK 标志的数据包给服务器。

**为什么是三次握手？**

因为，要确保通讯可靠就需要让双方知道互相发送消息是无误的。

即是要满足以下四点：
1. 客户端要知道 自己发送给服务器的消息可以成功到达；
2. 客户端要知道 服务器发送给自己的消息可以成功到达；
3. 服务器要知道 客户端发送自己给的消息可以成功到达；
4. 服务器要知道 自己发送给客户端的消息可以成功到达。

第一次握手时，服务器知道了 客户端 --> 自己可以到达，满足 3；
第二次握手时，客户端知道了 自己 --> 服务器 和 服务器 --> 自己可以到达，满足1 2；
第三次握手时，服务器知道了 自己 --> 客户端可以到达，满足 4。
所以需要三次，两次不能满足基本的可靠通讯，四次也不能100%的可靠。

**为什么TCP客户端最后还要发送一次确认呢？**
主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 4.4.2. TCP 四次挥手

TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是**全双工**的(即数据可在两个方向上同时传递)所以进行关闭时**每个方向上都要单独进行关闭**。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。

![image-20200330203017880](/images/image-20200330203017880.png)

- 客户端 发送一个 FIN，用来关闭客户端到服务器的数据传输；
- 服务器 收到这个 FIN 后，发回一个 ACK;
- 服务器 关闭与客户端的连接，发送一个 FIN 给客户端；
- 客户端 发回 ACK 报文确认。

为什么客户端发送完最后一个报文需要等待 2 msl?
**1、这是为了确认最后一条报文顺利到达了服务器端。**  
如果最后一条报文丢失了：那么服务器会在 1MSL 时重传倒数第二次的报文，这条报文会在 2MSL 时到达客户端。也就是说，如果客户端在2MSL时收到了一条重传报文，则说明最后一条确认报文丢失了；如果没有收到重传报文，则说明服务器接收到了最后一条确认报文，客户端可以关闭了。 
**2、确保本次连接中所有的报文都从网络中消失**


### 4.4.3. 滑动窗口协议
和连续 ARQ 协议很像
窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小

### 4.4.4. 流量控制

流量控制：控制发送方的发送窗口，让其发送速率不要太快，要让接收方来得及接受。
接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 4.4.5. 拥塞控制

（基于窗口的）拥塞控制四种算法：慢开始、拥塞避免、快重传、快恢复。

cwnd：拥塞窗口，发送方让自己的发送窗口等于拥塞窗口。注意：发送窗口一定小于对于接受窗口。
ssthresh：慢开始门限。
  if cwnd < ssthresh：慢开始
  if cwnd > ssthresh：拥塞避免


慢开始：以指数方式增长滑动窗口。每经过一个传输轮次，拥塞窗口 cwnd 加倍。
拥塞避免：每经过一个往返时间 RTT 就将拥塞窗口加一。
快重传：接受方发现有个别报文丢失时，会立即连续的发送三个相同的确认报文（而不会等待捎带确认）；发送方收到 3-ACK，就会对丢失的报文立即重传。
快恢复：ssthresh = cwnd / 2，cwnd = ssthresh

当超时：重新进入慢开始；当收到三个重复的确认报文（快重传）时，进入拥塞避免

![image-20200413165646760](/images/image-20200413165646760.png)
1、cwnd == ssthresh == 16 时：改用拥塞避免算法；
2、网络出现超时，发送方判断出现网络拥塞：ssthresh = cwnd / 2 = 12，cwnd = 1，进入慢开始；
3、同 1；
4、发送方连续收到 3 个相同的确认报文（此次使用快重传）：
5、快重传后，执行快恢复：ssthresh = cwnd / 2，cwnd = ssthresh，进入拥塞避免


# 5. 应用层与 HTTP 协议

![image-20200330202554664](/images/image-20200330202554664.png)

TCP:
- FTP：21，文件传输协议
- Telnet：23，远程登陆
- SMTP：25，邮件传送协议，发送邮件
- POP3：110，邮件传送协议，接受邮件
- HTTP：80，从 Web 服务器传输超文本到本地浏览器的协议

UDP:
- DNS：53，域名解析服务
- SNMP：161，简单网络管理协议
- TFTP：69，简单文件传输协议

## 5.1. 资源

Web 服务器是 web 资源的宿主，资源包括静态资源和动态资源。

### 5.1.1. 媒体类型 MIME

Multipurpose Internet Mail Extension，多用途因特网邮件扩展

互联网上的资源有多种类型，HTTP 协议通过使用 MIME 数据格式给每个资源打上不同的标签。
MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间 由一条斜杠来分隔。
- HTML 格式的文本文档由 text/html 类型来标记。
- 普通的 ASCII 文本文档由 text/plain 类型来标记。
- JPEG 版本的图片为 image/jpeg 类型。
- GIF 格式的图片为 image/gif 类型。
- Apple 的 QuickTime 电影为 video/quicktime 类型。
- 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。

### 5.1.2. URI

URI 统一资源标识符，用字符串标识某一互联网资源；URI 有两种形式，分别称为 URL 和 URN。
![image-20200410155806316](/images/image-20200410155806316.png)

#### 5.1.2.1. URL

URL 统一资源定位符，表示资源在互联网上所处的位置。它可以明确说明如何从一个精确、固定的位置获取资源。
URL 的格式
![image-20200410155836768](/images/image-20200410155836768.png)

URL 包括三个部分：
- 第一部分：方案（scheme），说明了访问资源所使用的协议类型。通常就是 HTTP 协议（http://）
- 第二部分：给出了服务器的因特网地址（比如，www.joes-hardware.com）
- 其余部分：指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）

#### 5.1.2.2. URN

- URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。
- 使用这些与位置无关的 URN，就可以将资源四处搬移。
- 通过 URN，还可以用同一个名字通过多种网络访问协议来访问资源。

> 比如，不论因特网标准文档 RFC 2141 位于何处（甚至可以将其复制到多个地方）， 都可以用下列 URN 来命名它： urn:ietf:rfc:2141

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png)

## 5.2. HTTP 协议

HTTP 是面向事务的应用层协议。HTTP 协议是无状态的。

### 5.2.1. HTTP 事务

一个 HTTP 事务由一条请求命令和一个响应结果组成。这种通信是通过名为 HTTP 报文（HTTP message）的格式化数据块进行的。

#### 5.2.1.1. 请求方法

**RESTful**:
REST，即Representational State Transfer 表现层状态转化
- GET（SELECT）：从服务器取出资源（一项或多项）。
- POST（CREATE）：在服务器新建一个资源。
- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。(id, new Object)
- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
- DELETE（DELETE）：从服务器删除资源。
- HEAD：获取资源的元数据。仅发送命名资源响应中的 HTTP 首部。
- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

**幂等**:
HTTP 幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。
- GET：用于获取资源，不管调用多少次接口，结果都不会改变，所以是**幂等的**。
- POST：是一个**非幂等**方法，因为调用多次，都将产生新的资源。
- PUT：因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足**幂等性**。
- PATCH：我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条 ticket 记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是**非幂等**的操作。比如点赞按钮。
- DELETE：调用一次和多次对资源产生影响是相同的，所以也满足**幂等性**。

**get 和 post 的区别**

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。

- GET参数通过URL传递，POST放在Request body中。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET请求只能进行 url 编码，而POST支持多种编码方式。

- GET产生的URL地址可以被Bookmark，而POST不可以。(Bookmark:加入书签)
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

- GET产生一个TCP数据包；POST产生两个TCP数据包。
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。


#### 5.2.1.2. 响应状态码

1XX：Information 信息性状态码，接受到请求正在处理
2XX：Success 成功状态码，请求正常处理完毕
3XX：Redirection 重定向状态码，需要进行附加操作以完成请求
4XX：Client Error 客户端错误状态码，服务器无法处理请求
5XX：Server Error 服务器错误状态码，服务器处理请求错误

- 200 OK：**请求已正常处理**
- 204 No Content：**请求处理成功，但没有任何资源可以返回给客户端**，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
- 206 Partial Content：**是对资源某一部分的请求**，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

- 301 Moved Permanently：**永久性重定向**。资源的 url 已更新，你也更新下你的书签引用吧。请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。
- 302 Found：**临时性重定向**。资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。
- 303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。
- 304 Not Modified：资源已找到，但未符合条件请求。
- 307 Temporary Redirect：临时重定向。与302有相同的含义。

- 400 Bad Request：服务器端无法理解客户端发送的请求，**请求报文中可能存在语法错误**。
- 401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。
- 403 Forbidden：**不允许访问**那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）
- 404 Not Found：服务器上没有请求的资源。路径错误等。

- 500 Internal Server Error：貌似**内部资源出故障了**。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。
- 503 Service Unavailable：抱歉，我现在**正在忙着**。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。

**状态码** http://www.ruanyifeng.com/blog/2014/05/restful_api.html

- 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
- 204 NO CONTENT - [DELETE]：用户删除数据成功。

- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。

- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。


### 5.2.2. HTTP 报文

```http
POST http://127.0.0.1:5000/songlist
Accept: */*
Cache-Control: no-cache
Content-Type: application/json
Authorization: eyJ0eXAi...

{ "name": "松松的歌单" }
```

HTTP 报文都是纯文本
```text
HTTP 报文
    |-- 请求报文
        |-- 请求起始行：请求方法 URI 协议版本
        |-- 请求首部字段
        |-- 请求主体
    |-- 响应报文
        |-- 响应起始行：协议版本 状态码 原因短语
        |-- 响应首部字段
        |-- 响应主体
```

HTTP 是无状态协议。
请求报文由 请求方法、请求 URI、协议版本、请求首部字段(可选)、内容实体 构成。
![image-20200410160414485](/images/image-20200410160414485.png)

响应报文由 协议版本、状态码、原因短语、响应首部字段(可选)、实体主体 构成。
![image-20200410161101659](/images/image-20200410161101659.png) 

#### 5.2.2.1. 首部字段

> https://www.cnblogs.com/xzsty/p/11452610.html

**1、通用首部字段**
请求报文和响应报文都会使用到的首部字段。

|首部字段名|含义|
|:-:|:-:|
|==Cache-Control==|==控制缓存的行为==|
|Connection|连接的管理|
|Date|创建报文的日期时间|
|Pragma|报文指令|
|Trailer|报文末端的首部一览|
|Transfer-Encoding|指定报文主体的传输编码方式|
|Upgrade|升级为其他协议|
|Via|代理服务器的相关信息|
|Warning|错误通知|

**2、请求首部字段**
|首部字段名|含义|
|:-:|:-:|
|==Accept==|==用户代理可处理的媒体类型==|
|Accept-Charset|优先的字符集|
|Accept-Encoding|优先的内容编码|
|Accept-Language|优先的语言（自然语言）|
|Authorization|Web认证信息|
|Expect|期待服务器的特定行为|
|From|用户的电子邮箱地址|
|==Host==|==请求资源所在服务器==|
|If-Match|比较实体标记（ETag）|
|If-Modified-Since|比较资源的更新时间|
|If-None-Match|比较实体标记（与 If-Match 相反）|
|If-Range|资源未更新时发送实体 Byte 的范围请求|
|If-Unmodified-Since|比较资源的更新时间（与If-Modified-Since相反）|
|Max-Forwards|最大传输逐跳数|
|Proxy-Authorization|代理服务器要求客户端的认证信息|
|Range|实体的字节范围请求|
|Referer|对请求中URI的原始获取方|
|TE|传输编码的优先级|
|User-Agent|HTTP客户端程序的信息|

**3、响应首部字段**
|首部字段名|含义|
|:-:|:-:|
|Accept-Ranges|是否接受字节范围请求|
|==Age==|==推算资源创建经过时间==|
|ETag|资源的匹配信息|
|==Location==|==令客户端重定向至指定URI==|
|Proxy-Authenticate|代理服务器对客户端的认证信息|
|Retry-After|对再次发起请求的时机要求|
|==Server==|==HTTP服务器的安装信息==|
|Vary|代理服务器缓存的管理信息|
|WWW-Authenticate|服务器对客户端的认证信息|

**4、实体首部字段**
|首部字段名|含义|
|:-:|:-:|
|Allow|资源可支持的HTTP方法|
|Content-Encoding|实体主体适用的编码方式|
|Content-Language|实体主体的自然语言|
|==Content-Length==|==实体主体的大小（单位：字节）==|
|Content-Location|替代对应资源的URI|
|Content-MD5|实体主体的报文摘要|
|Content-Range|实体主体的位置范围|
|==Content-Type==|==实体主体的媒体类型==|
|Expires|实体主体过期的日期时间|
|Last-Modified|资源的最后修改日期时间|

**几个重要首部字段及其指令**

【1、Cache-Control】
|缓存请求指令|参数|含义|
|:-:|:-:|:-:|
|no-cache|无|强制向原服务器再次验证|
|no-store|无|不缓存请求或响应的任何内容|
|max-age = [ 秒]|必须|响应的最大Age值|
|max-stale( = [ 秒])|可省略|接收已过期的响应|
|min-fresh = [ 秒]|必需|期望在指定的时间内的响应仍有效|
|no-transform|无|代理不可更改媒体类型|
|only-if-cached|无|代理不可更改媒体类型|
|cache-extension|无|新指令标记（token）|

|缓存响应指令|参数|含义|
|:-:|:-:|:-:|
|public|无|可向任意方提供响应的缓存|
|private|可省略|仅向特定用户返回响应|
|no-cache|可省略|缓存前必需先确认其有效性|
|no-store|无|不缓存请求或响应的任何内容|
|no-transform|无|代理不可更改媒体类型|
|must-revalidate|无|可缓存但必须再向源服务器进行确认|
|proxy-revalidate|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
|max-age=[秒]|必需|响应的最大Age值|
|s-maxage=[秒]|必需|公共缓存服务器响应的最大Age值|
|cache-extension|-|新指令标记（token）|


### 5.2.3. HTTPS

HTTP协议以明文方式发送内容，不提供任何方式的数据加密。

HTTP + 加密 + 认证 + 完整性保护 = HTTPS

安全套接字层 超文本传输协议HTTPS：为了数据传输的安全，**在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密**。

HTTPS 的作用：1、建立一个安全的信息通道；2、确认网站的真实性。

**HTTP与HTTPS的区别:**
1. HTTPS 需要申请 CA 证书。
2. HTTP 是明文传输数据的；HTTPS则是具有安全性的SSL加密传输协议。
3. HTTP 默认端口号 80；HTTPS 默认端口号 443。
4. HTTP 连接比较简单，是无状态的；HTTPS 可以加密传输和进行身份认证。
5. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。

#### 5.2.3.1. SSL握手

在发送已加密的 HTTP 报文之前，客户端和服务器要进行一次 SSL 握手，需要完成一下任务：
- 交换协议版本号； 
- 选择一个两端都了解的密码； 
- 对两端的身份进行认证； 
- 生成临时的会话密钥，以便加密信道。

**HTTPS 的连接流程：**
- TCP 三次握手
- 客户端向服务器发送自己支持的加密算法，并请求服务器的数字证书。
- 服务器进行算法协商。将协商好的加密算法和公钥，以及自己的数字证书发给客户端。
- 客户端验证服务器数字证书。生成会话使用的对称密钥。然后使用服务器的公钥将会话密钥加密发给服务器。
- 服务器使用私钥解码会话密钥。
- SSL 安全加密隧道协商完成，之后的通讯就可以使用对称的会话密钥进行了。

网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

**客户端验证证书：**
客户端在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。

**算法协商：**
1. 浏览器把自己支持的密钥算法套件发给服务器
2. 服务器接受到后，与自己支持的套件做对比。如果找到双方都支持的，则告知浏览器；如果没有，则浏览器会报错。
3. 浏览器和服务器使用匹配的密钥算法套件进行通讯。

```sequence
client -> server : 1.SSL版本，支持的加密算法，请求数字证书
server -> server : 2.进行算法协商
server -> client : 3.SSL版本，协商好的加密算法，服务器公钥，数字证书
client -> client : 4.验证数字证书，生成对称的会话密钥
client -> server : 5.经服务器公钥加密后的会话密钥
server -> server : 6.使用私钥解密会话密钥

client -> server : 7.经对称的会话密钥加密的请求报文
server -> client : 8.经对称的会话密钥加密的响应报文
```

```sequence
client -> server : 1.Handshake: ClientHello  （SSL版本，加密组件）

server -> client : 2.Handshake: ServerHello  （SSL版本，协商后的加密组件）
server -> client : 3.Handshake: Certificate  （公钥，证书）
server -> client : 4.Handshake: ServerHelloDone  （第一次握手结束：协商阶段）

client -> server : 5.Handshake: ClientKeyExchange  （公钥加密后的会话密钥）
client -> server : 6.ChangeClipherSpec  （会话密钥加密的）
client -> server : 7.Handshake: Finished  （前面所有报文的整体校验值。第二次握手结束：会话密钥）

server -> client : 8.ChangeClipherSpec  （同上，6和8是为了测试双方都可以使用会话密钥进行通信）
server -> client : 9.Handshake: Finished  （第三次握手结束：确认通信）
```

Handshake 握手
Certificate 证书