<h1 align="center">数据结构与算法</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. 查找算法](#1-查找算法)
  - [1.1. 二分查找](#11-二分查找)
- [2. 排序算法](#2-排序算法)
  - [2.1. 冒泡排序](#21-冒泡排序)
  - [2.2. 插入排序](#22-插入排序)
  - [2.3. 选择排序](#23-选择排序)
  - [2.4. 快速排序](#24-快速排序)

<!-- /code_chunk_output -->

# 1. 基础算法

## 1.1. 查找算法

### 1.1.1. 二分查找

```java
public int binarySearch(int[] arr, int data) {
    int min = 0;
    int max = arr.length - 1;
    int mid = -1;

    // 当min和max相等时，mid == min == max
    while (min <= max) {
        // 防止溢出
        mid =  min + (max - min) / 2;
        if (arr[mid] > data) {
            max = mid - 1;
        } else if (arr[mid] < data) {
            min = mid + 1;
        } else {
            return mid;
        }
    }
    return -1;
}
```

## 1.2. 排序算法

### 1.2.1. 冒泡排序

每趟排序，比较前后相邻的两个数，将较大的数往后移动。一趟完成之后，最大的数就沉到后面去了。

时间复杂度：$$o(n^2) = (n-1) + (n-2) + ··· + 1 =  \frac{(1 + (n-1))·(n-1)}{2} = \frac{1}{2}n^2 - \frac{1}{2}n$$ 
空间复杂度：$$o(1)$$

```java
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2 ,1, 0, 1, -2};
        System.out.println("初始: "+Arrays.toString(arr));
        bubbleSort(arr);
    }

    public static void bubbleSort(int[] arr) {
        // i 表示当前是第 i 躺排序
        for (int i = 0; i < arr.length; i++) {
            // 从 0（j-1） 开始将较大的数往后移动
            for (int j = 1; j < arr.length - i; j++) {
                if (arr[j-1] > arr[j]) {
                    int temp = arr[j-1];
                    arr[j-1] = arr[j];
                    arr[j] = temp;
                }
            }
            System.out.println("第"+(i+1)+"趟: "+Arrays.toString(arr));
        }
    }
}
```

### 1.2.2. 插入排序

通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应的位置并插入。
插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。

时间复杂度：$$o(n^2)$$
空间复杂度：$$o(1)$$

```java
public class InsertSort {
    public static void main(String[] args) {
        int[] arr = {9, 48, 7, 6, 15, 4, 33, 2 ,1, 0, 1, -2};
        System.out.println("初始: "+ Arrays.toString(arr));
        insertSort(arr);
    }

    public static void insertSort(int[] arr) {
        // 从第二和数开始，把arr[i]插入到前面排好的数组中
        for (int i = 1; i < arr.length; i++) {
            // temp 是待插入的数
            int temp = arr[i];
            // 0 到 i-1 是已经排好的数组
            int j;
            // 从后往前比较，将比temp大的数往后移动一位
            // 当temp比当前位置大时，上一个位置就是temp要插入进去的位置啦
            for (j = i-1; j >= 0; j--) {
                if (arr[j] > temp) {
                    arr[j+1] = arr[j];
                } else {
                    break;
                }
            }
            arr[j+1] = temp;
            System.out.println("第"+(i)+"趟: "+Arrays.toString(arr));
        }
    }
}
```

### 1.2.3. 选择排序

每趟排序遍历一遍未排序的部分，记录下最小数的下标。将最小数交换到小标为 i 的位置。

时间复杂度：$$o(n^2)$$
空间复杂度：$$o(1)$$

```java
public class SelectionSort {
    public static void main(String[] args) {
        int[] arr = {9, 48, 7, 6, 15, 4, 33, 2 ,1, 0, 1, -2};
        System.out.println("初始: "+ Arrays.toString(arr));
        selectionSort(arr);
    }

    public static void selectionSort(int[] arr) {
        // 每趟将最小的数调到前面去 调到位置为 i 处
        for (int i = 0; i < arr.length-1; i++) {
            // min 是当前这一趟最小元素的下标
            int min = i;
            for (int j = i + 1; j < arr.length; j++) {
                // 更新最小数的下标
                if (arr[j] < arr[min]) {
                    min = j;
                }
            }
            // 如果最小元素下标不是 i，就需要将交换
            if (i != min) {
                int temp = arr[min];
                arr[min] = arr[i];
                arr[i] = temp;
            }
            System.out.println("第"+(i+1)+"趟: "+Arrays.toString(arr));
        }
    }
}
```

### 1.2.4. 快速排序

每次排序确定当前部分最左边元素的最终位置。然后分别递归左右两边。

时间复杂度：$$o(nlog(n))$$
空间复杂度：$$o(log(n))$$

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {9, 8, 7, 6, 5, 4, 3, 2 ,1, 0, 1, -2};
        quickSort(arr, 0, arr.length-1);

        System.out.println(Arrays.toString(arr));
    }

    static void quickSort(int[] arr, int left, int right){
        if(left < right){
            int mid = part(arr, left, right);
            quickSort(arr, left, mid-1);
            quickSort(arr, mid+1, right);
        }
    }

    static int part(int[] arr, int left, int right){
        // 基准数
        int base = arr[left];
        // 当 left == right 时退出
        while(left < right){
            // 从右往左找比 base 小的
            while(left < right && base <= arr[right]){
                right--;
            }
            arr[left] = arr[right];
            // 从左往右找比 base 大的
            while(left < right && base >= arr[left]){
                left++;
            }
            arr[right] = arr[left];
        }
        arr[left] = base;
        return left;
    }
}
```

# 2. 基础数据结构

## 2.1. 栈

特点：先进后出
操作：入栈 push、出栈 pop

java.util 包中的 Stack 类继承自 Vector。它是线程安全的，它的方法都是同步方法

```java
package java.util;
public class Stack<E> extends Vector<E> {
    // 构造器: 只有一个空参构造器
    // 调用其父类Vector的空参构造，设置初始大小为 10
    // public Vector() {
    //     this(10);
    // }
    public Stack() {
    }
    // 入栈
    // 返回: 刚刚入栈的元素
    E push(E item);
    // 出栈
    // 返回: 刚刚出栈的元素
    // 异常: 如果栈为空, java.util.EmptyStackException
    E pop();
    // 获取栈顶元素
    // 返回: 栈顶元素
    // 异常: 如果栈为空, java.util.EmptyStackException
    E peek();
    // 判断栈是否为空
    boolean empty();
    // 从栈顶往下找目标元素 o
    // 返回: 第一个 o 在第几个位置上（栈顶元素为 1 号，往下依次 2,3,4...）
    //       如果没找到 o, 返回 -1
    // 例如： 目前栈中有：（栈底）1,2,3,1,2,3,4（栈顶）。search(2) == 3
    int search(Object o) {
        int i = lastIndexOf(o);
        if (i >= 0) {
            return size() - i;
        }
        return -1;
    }
}
```

## 2.2. 队列

特点：先进先出
操作：入队 offer，出队 poll

```java
package java.util;
public interface Queue<E> extends Collection<E> {
    // 入队，向队尾添加元素
    // 返回: 插入成功返回 true；否则返回false
    boolean offer(E e);

    // 出队，删除队头元素
    // 返回: 刚刚出队的元素；如果队列为空，返回 null
    E poll();
    // 获取队头元素
    // 返回: 对头元素，如果队列为空，返回 null
    E peek();
}
```
队列是一个接口，有一个实现类 LinkedList。

## 2.3. 链表

## 2.4. 散列表

## 2.5. 二叉树

### 2.5.1. 排序二叉树

### 2.5.2. 红黑树

### 2.5.3. B-树

## 2.6. 位图