<h1 id="软件工程" align="center">软件工程</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. 软件过程](#1-软件过程)
  - [1.1. 软件过程模型](#11-软件过程模型)
    - [1.1.1. 瀑布模型](#111-瀑布模型)
    - [1.1.2. 敏捷开发](#112-敏捷开发)

<!-- /code_chunk_output -->

# 1. 软件过程

软件过程：软件产品生产的一组相互关联的活动。

## 1.1. 过程活动

1. 软件规格说明：软件的功能以及对于软件运行的约束必须在这里进行定义。
2. 软件开发：必须开发出符合规格说明的软件。
3. 软件确认：软件必须通过确认来确保软件所做的是客户所想要的。
4. 软件演化：软件必须通过演化来满足不断变化的客户需要。

## 1.2. 软件过程模型

**1. 瀑布模型**

```ditaa {cmd=true args=["-E"]}
+---------+
+ 需求定义 +----+
+---------+    |
   ^           |
   |           v
   |   +---------------+
   |   + 系统和软件设计 +-------+
   |   +---------------+       |
   |           ^               |
   |           |               v
   |           |        +---------------+
   |           |        + 实现与单元测试 +-----+
   |           |        +---------------+     |
   |           |               ^              |
   |           |               |              v
   |           |               |      +---------------+
   |           |               |      + 集成与系统测试 +----+
   |           |               |      +---------------+    |
   |           |               |              ^            |
   |           |               |              |            v
   |           |               |              |       +-----------+
   +-----------+---------------+--------------+-------+ 运行与维护 +
                                                      +-----------+
```

**2. 增量式开发**

**3. 集成与配置**


## 1.3. 敏捷软件开发

敏捷开发的核心是迭代开发。敏捷一定是采用迭代开发的方式。增量开发加上迭代开发，才算真正的敏捷开发。

**迭代开发（iterative development）**  
迭代开发将一个大任务，分解成多次连续的开发，本质就是逐步改进。  
每一次迭代都包含规划、设计、编码、测试、评估五个步骤。

**增量开发（incremental development）**  
增量开发指的是软件的每个版本，都会新增一个用户可以感知的完整功能。也就是说，按照新增功能来划分迭代。

**好处**  
- 早期交付，从而大大降低成本
- 降低风险，及时了解市场需求，降低产品不适用的风险

每个迭代大约持续2~6周。完成以下五个步骤：  
1. 需求分析（requirements analysis）
2. 设计（design）
3. 编码（coding）
4. 测试（testing）
5. 部署和评估（deployment / evaluation）

**《敏捷软件开发宣言》里面提到四个价值观。**  
- 程序员的主观能动性，以及程序员之间的互动，优于既定流程和工具。
- 软件能够运行，优于详尽的文档。
- 跟客户的密切协作，优于合同和谈判。
- 能够响应变化，优于遵循计划。

**该宣言还提出十二条敏捷开发的原则。**  
- 通过早期和持续交付有价值的软件，实现客户满意度。
- 欢迎不断变化的需求，即使是在项目开发的后期。要善于利用需求变更，帮助客户获得竞争优势。
- 不断交付可用的软件，周期通常是几周，越短越好。
- 项目过程中，业务人员与开发人员必须在一起工作。
- 项目必须围绕那些有内在动力的个人而建立，他们应该受到信任。
- 面对面交谈是最好的沟通方式。
- 可用性是衡量进度的主要指标。
- 提倡可持续的开发，保持稳定的进展速度。
- 不断关注技术是否优秀，设计是否良好。
- 简单性至关重要，尽最大可能减少不必要的工作。
- 最好的架构、要求和设计，来自团队内部自发的认识。
- 团队要定期反思如何更有效，并相应地进行调整

**理解**  
持续交付，持续迭代，需求分析和设计才是关键

# 2. 需求工程

## 2.1. 可行性研究

**可行性研究**：是一个应当在需求工程早期进行的简短、聚焦的研究。其应该回答以下问题：
1. 系统是否可以服务于组织的总体目标？
2. 系统是否可以在进度和预算范围内用当前的技术实现？
3. 系统是否可以与所使用的其他系统相集成？

## 2.2. 用户需求与系统需求

用户需求指高层的抽象需求；系统需求指关于系统应当做什么的详细描述：
1. **用户需求**使用自然语言和图形，陈述系统被期望向系统用户提供什么服务以及系统运行必须满足的约束。用户需求可以是对系统特征的大概陈述，也可以是关于系统功能的详细和精确的描述。
2. **系统需求**是对软件系统的功能、服务和运行约束的更详细的描述。系统需求文档（有时候被称为**功能规格说明**）应该精确定义要实现哪些东西。它可以是系统购买方和软件开发者之间合同的一部分。

- 用户需求的读者通常并不关心系统如何实现，可能是对系统的详细实现不感兴趣的管理人员。
- 系统需求的读者需要更精确地了解系统要做什么，因为他们关心系统将如何支持业务过程或者他们本身参与系统实现。

## 2.3. 功能性需求和与功能性需求

1. **功能性需求**。这些需求是对系统应该提供的服务、系统应该如何响应特定的输入、系统在特定的情形中应该如何表现等的陈述。在某些情况下，功能性需求还可以明确地陈述系统不应该做什么。
2. **非功能性需求**。这些需求是对系统提供的服务或功能的约束，包括时间性约束、对于开发过程的约束、标准规范中所施加的约束等。非功能性需求经常适用于系统整体而不是单个的系统特征或服务。

需求不是独立的，一个需求经常会产生其他需求，或对其他需求产生约束。

功能性需求将用户需求展开，是面向系统开发者描述的，应当详细描述系统功能，系统的输入、输出和异常。

非功能性需求类型：  
- 产品需求
  - 易用性需求
  - 效率需求
    - 性能需求
    - 空间需求
  - 可依赖性需求
  - 信息安全需求
- 组织需求
  - 环境需求
  - 运行需求
  - 开发需求
- 外部需求
  - 监管需求
  - 道德需求
  - 法律需求
    - 会计需求
    - 安全性、信息安全需求


## 2.4. 需求工程过程

1. 需求抽取和分析：通过与利益相关者交互发现需求。
2. 需求规格说明：将这些需求转化为标准格式。
3. 需求确认：检查需求是否实际上定义了客户所要的系统。

需求工程过程的输出是一个**系统需求文档**。

```
需求抽取     |    需求规格说明          |  需求确认         |
------------------------------------------------------------
开始         -->  业务需求规格说明        -->  可行性研究  --> 
用户需求抽取  -->  用户需求规格说明        -->  原型       --> 
系统需求抽取  -->  系统需求规格说明和建模  -->   评审       -->  输出：系统需求文档
```